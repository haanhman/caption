{"0":{"dur":2,"text":"[Section 4 - More Comfortable]"},"2":{"dur":2,"text":"[Rob Bowden - Harvard University]"},"4":{"dur":2,"text":"[This is CS50. - CS50.TV]"},"8":{"dur":4,"text":"We have a quiz tomorrow, in case you guys didn't know that."},"14":{"dur":6,"text":"It's basically on everything you could have seen in class or should have seen in class."},"20":{"dur":5,"text":"That includes pointers, even though they're a very recent topic."},"26":{"dur":3,"text":"You should at least understand the high levels of them."},"29":{"dur":4,"text":"Anything that was gone over in class you should understand for the quiz."},"34":{"dur":2,"text":"So if you have questions on them, you can ask them now."},"37":{"dur":5,"text":"But this is going to be a very student-led session where you guys ask questions,"},"43":{"dur":1,"text":"so hopefully people have questions."},"45":{"dur":2,"text":"Does anyone have questions?"},"49":{"dur":2,"text":"Yes. >>[student] Can you go over pointers again?"},"52":{"dur":2,"text":"I'll go over pointers."},"54":{"dur":4,"text":"All of your variables necessarily live in memory,"},"59":{"dur":5,"text":"but usually you don't worry about that and you just say x + 2 and y + 3"},"64":{"dur":2,"text":"and the compiler will figure out where the things are living for you."},"67":{"dur":5,"text":"Once you're dealing with pointers, now you're explicitly using those memory addresses."},"72":{"dur":6,"text":"So a single variable will only ever live at a single address at any given time."},"79":{"dur":4,"text":"If we want to declare a pointer, what is the type going to look like?"},"84":{"dur":2,"text":"I want to declare a pointer p. What does the type look like?"},"86":{"dur":7,"text":"[student] int *p. >>Yeah. So int *p."},"93":{"dur":4,"text":"And how do I make it point to x? >>[student] Ampersand."},"100":{"dur":4,"text":"[Bowden] So ampersand is literally called the address of operator."},"105":{"dur":5,"text":"So when I say &x it's getting the memory address of the variable x."},"110":{"dur":6,"text":"So now I have the pointer p, and anywhere in my code I can use *p"},"116":{"dur":6,"text":"or I could use x and it will be the exact same thing."},"122":{"dur":6,"text":"(*p). What is this doing? What does that star mean?"},"129":{"dur":3,"text":"[student] It means a value at that point. >>Yeah."},"133":{"dur":4,"text":"So if we look at it, it can be very useful to draw out the diagrams"},"137":{"dur":4,"text":"where this is a little box of memory for x, which happens to have the value 4,"},"142":{"dur":3,"text":"then we have a little box of memory for p,"},"145":{"dur":5,"text":"and so p points to x, so we draw an arrow from p to x."},"151":{"dur":8,"text":"So when we say *p we're saying go to the box that is p."},"160":{"dur":6,"text":"Star is follow the arrow and then do whatever you want with that box right there."},"166":{"dur":14,"text":"So I can say *p = 7; and that will go to the box that is x and change that to 7."},"181":{"dur":12,"text":"Or I could say int z = *p * 2; That's confusing because it's star, star."},"193":{"dur":5,"text":"The one star is dereferencing p, the other star is multiplying by 2."},"199":{"dur":7,"text":"Notice I could have just as well replaced the *p with x."},"206":{"dur":2,"text":"You can use them in the same way."},"209":{"dur":8,"text":"And then later on I can have p point to a completely new thing."},"218":{"dur":4,"text":"I can just say p = &z;"},"222":{"dur":2,"text":"So now p no longer points to x; it points to z."},"224":{"dur":5,"text":"And any time I do *p it's the same as doing z."},"230":{"dur":5,"text":"So the useful thing about this is once we start getting into functions."},"236":{"dur":3,"text":"It's kind of useless to declare a pointer that points to something"},"239":{"dur":3,"text":"and then you're just dereferencing it"},"243":{"dur":2,"text":"when you could have used the original variable to begin with."},"246":{"dur":12,"text":"But when you get into functions--so let's say we have some function, int foo,"},"258":{"dur":14,"text":"that takes a pointer and just does *p = 6;"},"272":{"dur":7,"text":"Like we saw before with swap, you can't do an effective swap and a separate function"},"279":{"dur":5,"text":"by just passing integers because everything in C is always passing by value."},"285":{"dur":3,"text":"Even when you're passing pointers you're passing by value."},"288":{"dur":3,"text":"It just so happens that those values are memory addresses."},"291":{"dur":8,"text":"So when I say foo(p); I'm passing the pointer into the function foo"},"300":{"dur":3,"text":"and then foo is doing *p = 6;"},"303":{"dur":4,"text":"So inside of that function, *p is still equivalent to x,"},"308":{"dur":4,"text":"but I can't use x inside of that function because it's not scoped within that function."},"312":{"dur":6,"text":"So *p = 6 is the only way I can access a local variable from another function."},"319":{"dur":4,"text":"Or, well, pointers are the only way I can access a local variable from another function."},"323":{"dur":8,"text":"[student] Let's say you wanted to return a pointer. How exactly do you do that?"},"331":{"dur":12,"text":"[Bowden] Return a pointer as in something like int y = 3; return &y? >>[student] Yeah."},"344":{"dur":4,"text":"[Bowden] Okay. You should never do this. This is bad."},"348":{"dur":11,"text":"I think I saw in these lecture slides you started seeing this whole diagram of memory"},"359":{"dur":3,"text":"where up here you've got memory address 0"},"362":{"dur":6,"text":"and down here you have memory address 4 gigs or 2 to the 32."},"369":{"dur":5,"text":"So then you've got some stuff and some stuff and then you have your stack"},"375":{"dur":6,"text":"and you've got your heap, which you just started learning about, growing up."},"381":{"dur":2,"text":"[student] Isn't the heap above the stack?"},"384":{"dur":3,"text":"Yeah. The heap is on top, isn't it? >>[student] Well, he put 0 on top."},"387":{"dur":2,"text":"[student] Oh, he put 0 on top. >>[student] Oh, okay."},"390":{"dur":5,"text":"Disclaimer: Anywhere with CS50 you're going to see it this way. >>[student] Okay."},"396":{"dur":4,"text":"It's just that when you're first seeing stacks,"},"400":{"dur":4,"text":"like when you think of a stack you think of stacking things on top of one another."},"405":{"dur":5,"text":"So we tend to flip this around so the stack is growing up like a stack normally would"},"410":{"dur":5,"text":"instead of the stack hanging down. >>[student] Don't heaps technically grow up too, though?"},"415":{"dur":5,"text":"It depends on what you mean by grow up."},"421":{"dur":2,"text":"The stack and heap always grow in opposite directions."},"424":{"dur":5,"text":"A stack is always growing up in the sense that it's growing up"},"429":{"dur":3,"text":"towards higher memory addresses, and the heap is growing down"},"432":{"dur":4,"text":"in that it's growing towards lower memory addresses."},"437":{"dur":2,"text":"So the top is 0 and the bottom is high memory addresses."},"440":{"dur":6,"text":"They're both growing, just in opposing directions."},"446":{"dur":2,"text":"[student] I just meant that because you said you put stack on the bottom"},"449":{"dur":4,"text":"because it seems more intuitive because for the stack to start at the top of a heap,"},"453":{"dur":3,"text":"heap's on top of itself too, so that's-- >>Yeah."},"457":{"dur":7,"text":"You also think of the heap as growing up and larger, but the stack more so."},"464":{"dur":5,"text":"So the stack is the one that we kind of want to show growing up."},"470":{"dur":5,"text":"But everywhere you look otherwise is going to show address 0 at the top"},"475":{"dur":4,"text":"and the highest memory address at the bottom, so this is your usual view of memory."},"479":{"dur":2,"text":"Do you have a question?"},"482":{"dur":2,"text":"[student] Can you tell us more about the heap?"},"484":{"dur":1,"text":"Yeah. I'll get to that in a second."},"486":{"dur":6,"text":"First, going back to why returning &y is a bad thing,"},"492":{"dur":6,"text":"on the stack you have a bunch of stack frames which represent all of the functions"},"498":{"dur":1,"text":"which have been called."},"500":{"dur":7,"text":"So ignoring previous things, the top of your stack is always going to be the main function"},"507":{"dur":5,"text":"since that's the first function that's being called."},"513":{"dur":4,"text":"And then when you call another function, the stack is going to grow down."},"517":{"dur":4,"text":"So if I call some function, foo, and it gets its own stack frame,"},"521":{"dur":5,"text":"it can call some function, bar; it gets its own stack frame."},"527":{"dur":2,"text":"And bar could be recursive and it could call itself,"},"529":{"dur":4,"text":"and so that second call to bar is going to get its own stack frame."},"534":{"dur":4,"text":"And so what goes in these stack frames are all of the local variables"},"538":{"dur":4,"text":"and all of the function arguments that--"},"543":{"dur":5,"text":"Any things that are locally scoped to this function go in these stack frames."},"548":{"dur":12,"text":"So that means when I said something like bar is a function,"},"561":{"dur":7,"text":"I'm just going to declare an integer and then return a pointer to that integer."},"569":{"dur":4,"text":"So where does y live?"},"573":{"dur":3,"text":"[student] y lives in bar. >>[Bowden] Yeah."},"576":{"dur":8,"text":"Somewhere in this little square of memory is a littler square that has y in it."},"585":{"dur":8,"text":"When I return &y, I'm returning a pointer to this little block of memory."},"593":{"dur":5,"text":"But then when a function returns, its stack frame gets popped off the stack."},"601":{"dur":2,"text":"And that's why it's called stack."},"603":{"dur":3,"text":"It's like the stack data structure, if you know what that is."},"606":{"dur":5,"text":"Or even like a stack of trays is always the example,"},"611":{"dur":4,"text":"main is going to go on the bottom, then the first function you call is going to go on top of that,"},"616":{"dur":4,"text":"and you can't get back to main until you return from all functions which have been called"},"620":{"dur":1,"text":"that have been placed on top of it."},"622":{"dur":6,"text":"[student] So if you did do return the &y, that value is subject to change without notice."},"628":{"dur":2,"text":"Yes, it's-- >>[student] It could be overwritten. >>Yeah."},"631":{"dur":3,"text":"It's completely-- If you try and--"},"634":{"dur":3,"text":"This would also be an int *bar because it's returning a pointer,"},"638":{"dur":3,"text":"so its return type is int *."},"641":{"dur":5,"text":"If you try to use the return value of this function, it's undefined behavior"},"646":{"dur":5,"text":"because that pointer points to bad memory. >>[student] Okay."},"651":{"dur":9,"text":"So what if, for example, you declared int *y = malloc(sizeof(int))?"},"661":{"dur":2,"text":"That's better. Yes."},"663":{"dur":3,"text":"[student] We talked about how when we drag things to our recycle bin"},"667":{"dur":4,"text":"they're not actually erased; we just lose their pointers."},"671":{"dur":3,"text":"So in this case do we actually erase the value or is it still there in memory?"},"675":{"dur":3,"text":"For the most part, it's going to still be there."},"679":{"dur":5,"text":"But let's say we happen to call some other function, baz."},"684":{"dur":4,"text":"Baz is going to get its own stack frame on here."},"688":{"dur":2,"text":"It's going to be overwriting all of this stuff,"},"691":{"dur":2,"text":"and then if you later try and use the pointer that you got before,"},"694":{"dur":1,"text":"it's not going to be the same value."},"695":{"dur":2,"text":"It's going to have changed just because you called the function baz."},"698":{"dur":4,"text":"[student] But had we not, would we still get 3?"},"703":{"dur":1,"text":"[Bowden] In all likelihood, you would."},"704":{"dur":4,"text":"But you can't rely on that. C just says undefined behavior."},"709":{"dur":2,"text":"[student] Oh, it does. Okay."},"711":{"dur":6,"text":"So when you want to return a pointer, this is where malloc comes in use."},"720":{"dur":15,"text":"I'm writing actually just return malloc(3 * sizeof(int))."},"737":{"dur":6,"text":"We'll go over malloc more in a second, but the idea of malloc is all of your local variables"},"744":{"dur":2,"text":"always go on the stack."},"746":{"dur":4,"text":"Anything that's malloced goes on the heap, and it will forever and always be on the heap"},"751":{"dur":2,"text":"until you explicitly free it."},"754":{"dur":7,"text":"So this means that when you malloc something, it's going to survive after the function returns."},"762":{"dur":4,"text":"[student] Will it survive after the program stops running? >>No."},"766":{"dur":6,"text":"Okay, so it's going to be there until the program is all the way done running. >>Yes."},"773":{"dur":4,"text":"We can go over details of what happens when the program stops running."},"777":{"dur":4,"text":"You might need to remind me, but that is a separate thing entirely."},"782":{"dur":2,"text":"[student] So malloc creates a pointer? >>Yeah."},"784":{"dur":8,"text":"Malloc-- >>[student] I think malloc designates a block of memory that a pointer can use."},"795":{"dur":4,"text":"[Bowden] I want that diagram again. >>[student] So this function works, though?"},"799":{"dur":6,"text":"[student] Yeah, malloc designates a block of memory that you can use,"},"806":{"dur":4,"text":"and then it returns the address of the first block of that memory."},"810":{"dur":6,"text":"[Bowden] Yeah. So when you malloc, you're grabbing some block of memory"},"816":{"dur":1,"text":"that's currently in the heap."},"818":{"dur":4,"text":"If the heap is too small, then the heap is just going to grow, and it grows in this direction."},"823":{"dur":1,"text":"So let's say the heap is too small."},"824":{"dur":5,"text":"Then it's about to grow a little bit and return a pointer to this block that just grew."},"829":{"dur":5,"text":"When you free stuff, you're making more room in the heap,"},"835":{"dur":4,"text":"so then a later call to malloc can reuse that memory that you had previously freed."},"840":{"dur":9,"text":"The important thing about malloc and free is that it gives you complete control"},"849":{"dur":2,"text":"over the lifetime of these memory blocks."},"852":{"dur":2,"text":"Global variables are always alive."},"855":{"dur":3,"text":"Local variables are alive within their scope."},"858":{"dur":3,"text":"As soon as you go past a curly brace, the local variables are dead."},"862":{"dur":6,"text":"Malloced memory is alive when you want it to be alive"},"868":{"dur":4,"text":"and then is released when you tell it to be released."},"873":{"dur":4,"text":"Those are actually the only 3 types of memory, really."},"878":{"dur":3,"text":"There's automatic memory management, which is the stack."},"881":{"dur":2,"text":"Things happen for you automatically."},"883":{"dur":3,"text":"When you say int x, memory is allocated for int x."},"886":{"dur":4,"text":"When x goes out of scope, memory is reclaimed for x."},"891":{"dur":3,"text":"Then there's dynamic memory management, which is what malloc is,"},"894":{"dur":1,"text":"which is when you have control."},"896":{"dur":4,"text":"You dynamically decide when memory should and should not be allocated."},"901":{"dur":3,"text":"And then there's static, which just means that it lives forever,"},"905":{"dur":1,"text":"which is what global variables are."},"906":{"dur":3,"text":"They're just always in memory."},"910":{"dur":1,"text":"Questions?"},"914":{"dur":2,"text":"[student] Can you define a block just by using curly braces"},"917":{"dur":3,"text":"but not having to have an if statement or a while statement or anything like that?"},"921":{"dur":7,"text":"You can define a block as in a function, but that has curly braces too."},"929":{"dur":2,"text":"[student] So you can't just have like a random pair of curly braces in your code"},"932":{"dur":3,"text":"that have local variables? >>Yes, you can."},"935":{"dur":10,"text":"Inside of int bar we could have {int y = 3;}."},"945":{"dur":2,"text":"That's supposed to be right here."},"948":{"dur":4,"text":"But that completely defines the scope of int y."},"952":{"dur":4,"text":"After that second curly brace, y cannot be used anymore."},"957":{"dur":2,"text":"You almost never do that, though."},"962":{"dur":4,"text":"Getting back to what happens when a program ends,"},"967":{"dur":11,"text":"there's kind of a misconception\/half lie that we give in order to just make things easier."},"978":{"dur":5,"text":"We tell you that when you allocate memory"},"984":{"dur":5,"text":"you're allocating some chunk of RAM for that variable."},"989":{"dur":4,"text":"But you're not really directly touching RAM ever in your programs."},"994":{"dur":3,"text":"If you think of it, how I drew--"},"997":{"dur":6,"text":"And actually, if you go through in GDB you'll see the same thing."},"1011":{"dur":6,"text":"Regardless of how many times you run your program or what program you're running,"},"1017":{"dur":2,"text":"the stack is always going to start--"},"1019":{"dur":6,"text":"you're always going to see variables around address oxbffff something."},"1026":{"dur":2,"text":"It's usually somewhere in that region."},"1029":{"dur":9,"text":"But how can 2 programs possibly have pointers to the same memory?"},"1040":{"dur":7,"text":"[student] There's some arbitrary designation of where oxbfff is supposed to be on the RAM"},"1047":{"dur":3,"text":"that can actually be in different places depending on when the function was called."},"1051":{"dur":4,"text":"Yeah. The term is virtual memory."},"1055":{"dur":6,"text":"The idea is that every single process, every single program that is running on your computer"},"1062":{"dur":7,"text":"has its own--let's assume 32 bits--completely independent address space."},"1069":{"dur":2,"text":"This is the address space."},"1071":{"dur":4,"text":"It has its own completely independent 4 gigabytes to use."},"1076":{"dur":6,"text":"So if you run 2 programs simultaneously, this program sees 4 gigabytes to itself,"},"1082":{"dur":2,"text":"this program sees 4 gigabytes to itself,"},"1084":{"dur":2,"text":"and it's impossible for this program to dereference a pointer"},"1087":{"dur":3,"text":"and end up with memory from this program."},"1090":{"dur":7,"text":"And what virtual memory is is a mapping from a processes address space"},"1098":{"dur":2,"text":"to actual things on RAM."},"1100":{"dur":2,"text":"So it's up to your operating system to know that,"},"1102":{"dur":5,"text":"hey, when this guy dereferences pointer oxbfff, that really means"},"1108":{"dur":2,"text":"that he wants RAM byte 1000,"},"1111":{"dur":7,"text":"whereas if this program dereferences oxbfff, he really wants RAM byte 10000."},"1118":{"dur":3,"text":"They can be arbitrarily far apart."},"1121":{"dur":7,"text":"This is even true of things within a single processes address space."},"1128":{"dur":6,"text":"So like it sees all 4 gigabytes to itself, but let's say--"},"1134":{"dur":2,"text":"[student] Does every single process--"},"1137":{"dur":4,"text":"Let's say you have a computer with only 4 gigabytes of RAM."},"1141":{"dur":5,"text":"Does every single process see the whole 4 gigabytes? >>Yes."},"1146":{"dur":6,"text":"But the 4 gigabytes it sees is a lie."},"1153":{"dur":7,"text":"It's just it thinks it has all this memory because it doesn't know any other process exists."},"1160":{"dur":7,"text":"It will only use as much memory as it actually needs."},"1168":{"dur":4,"text":"The operating system is not going to give RAM to this process"},"1172":{"dur":3,"text":"if it's not using any memory in this entire region."},"1175":{"dur":3,"text":"It's not going to give it memory for that region."},"1179":{"dur":15,"text":"But the idea is that-- I'm trying to think of-- I can't think of an analogy."},"1194":{"dur":2,"text":"Analogies are hard."},"1197":{"dur":4,"text":"One of the issues of virtual memory or one of the things it's solving"},"1202":{"dur":4,"text":"is that processes should be completely unaware of one another."},"1206":{"dur":5,"text":"And so you can write any program that just dereferences any pointer,"},"1212":{"dur":7,"text":"like just write a program that says *(ox1234),"},"1219":{"dur":3,"text":"and that's dereferencing memory address 1234."},"1222":{"dur":5,"text":"But it's up to the operating system to then translate what 1234 means."},"1228":{"dur":5,"text":"So if 1234 happens to be a valid memory address for this process,"},"1233":{"dur":4,"text":"like it's on the stack or something, then this will return the value of that memory address"},"1238":{"dur":3,"text":"as far as the process knows."},"1241":{"dur":5,"text":"But if 1234 is not a valid address, like it happens to land"},"1247":{"dur":5,"text":"in some little piece of memory here that is beyond the stack and beyond the heap"},"1252":{"dur":4,"text":"and you haven't really used that, then that's when you get things like segfaults"},"1257":{"dur":3,"text":"because you're touching memory that you should not be touching."},"1267":{"dur":2,"text":"This is also true--"},"1269":{"dur":6,"text":"A 32-bit system, 32 bits means you have 32 bits to define a memory address."},"1275":{"dur":7,"text":"It's why pointers are 8 bytes because 32 bits are 8 bytes--or 4 bytes."},"1282":{"dur":2,"text":"Pointers are 4 bytes."},"1285":{"dur":8,"text":"So when you see a pointer like oxbfffff, that is--"},"1293":{"dur":6,"text":"Within any given program you can just construct any arbitrary pointer,"},"1300":{"dur":6,"text":"anywhere from ox0 to ox 8 f's--ffffffff."},"1306":{"dur":2,"text":"[student] Didn't you say they're 4 bytes? >>Yeah."},"1309":{"dur":3,"text":"[student] Then each byte will have-- >>[Bowden] Hexadecimal."},"1312":{"dur":6,"text":"Hexadecimal--5, 6, 7, 8. So pointers you're going to always see in hexadecimal."},"1319":{"dur":2,"text":"It's just how we classify pointers."},"1321":{"dur":3,"text":"Every 2 digits of hexadecimal is 1 byte."},"1325":{"dur":4,"text":"So there's going to be 8 hexadecimal digits for 4 bytes."},"1329":{"dur":4,"text":"So every single pointer on a 32-bit system is going to be 4 bytes,"},"1334":{"dur":4,"text":"which means that in your process you can construct any arbitrary 4 bytes"},"1338":{"dur":2,"text":"and make a pointer out of it,"},"1340":{"dur":12,"text":"which means that as far as it's aware, it can address an entire 2 to the 32 bytes of memory."},"1352":{"dur":2,"text":"Even though it doesn't really have access to that,"},"1354":{"dur":5,"text":"even if your computer only has 512 megabytes, it thinks it has that much memory."},"1360":{"dur":4,"text":"And the operating system is smart enough that it will only allocate what you actually need."},"1364":{"dur":4,"text":"It doesn't just go, oh, a new process: 4 gigs."},"1369":{"dur":2,"text":"Yeah. >>[student] What does the ox mean? Why do you write it?"},"1371":{"dur":3,"text":"It's just the symbol for hexadecimal."},"1374":{"dur":4,"text":"When you see a number start with ox, the successive things are hexadecimal."},"1381":{"dur":3,"text":"[student] You were explaining about what happens when a program ends. >>Yes."},"1385":{"dur":3,"text":"What happens when a program ends is the operating system"},"1389":{"dur":4,"text":"just erases the mappings that it has for these addresses, and that's it."},"1393":{"dur":4,"text":"The operating system can now just give that memory to another program to use."},"1397":{"dur":1,"text":"[student] Okay."},"1399":{"dur":5,"text":"So when you allocate something on the heap or the stack or global variables or anything,"},"1404":{"dur":2,"text":"they all just disappear as soon as the program ends"},"1407":{"dur":5,"text":"because the operating system is now free to give that memory to any other process."},"1412":{"dur":3,"text":"[student] Even though there are probably still values written in? >>Yeah."},"1415":{"dur":2,"text":"The values are likely still there."},"1417":{"dur":3,"text":"It's just it's going to be difficult to get at them."},"1421":{"dur":3,"text":"It's much more difficult to get at them than it is to get at a deleted file"},"1425":{"dur":6,"text":"because the deleted file kind of sits there for a long time and the hard drive is a lot bigger."},"1431":{"dur":2,"text":"So it's going to overwrite different parts of memory"},"1434":{"dur":4,"text":"before it happens to overwrite the chunk of memory that that file used to be at."},"1438":{"dur":5,"text":"But main memory, RAM, you cycle through a lot faster,"},"1444":{"dur":3,"text":"so it's going to very rapidly be overwritten."},"1450":{"dur":3,"text":"Questions on this or anything else?"},"1453":{"dur":2,"text":"[student] I have questions about a different topic. >>Okay."},"1456":{"dur":2,"text":"Does anyone have questions on this?"},"1460":{"dur":2,"text":"Okay. Different topic. >>[student] Okay."},"1463":{"dur":3,"text":"I was going through some of the practice tests,"},"1466":{"dur":3,"text":"and in one of them it was talking about the sizeof"},"1470":{"dur":5,"text":"and the value that it returns or different variable types. >>Yes."},"1475":{"dur":9,"text":"And it said that both int and long both return 4, so they're both 4 bytes long."},"1485":{"dur":3,"text":"Is there any difference between an int and a long, or is it the same thing?"},"1488":{"dur":2,"text":"Yes, there is a difference."},"1490":{"dur":2,"text":"The C standard--"},"1492":{"dur":1,"text":"I'm probably going to mess up."},"1494":{"dur":3,"text":"The C standard is just like what C is, the official documentation of C."},"1498":{"dur":1,"text":"This is what it says."},"1500":{"dur":8,"text":"So the C standard just says that a char will forever and always be 1 byte."},"1510":{"dur":8,"text":"Everything after that--a short is always just defined as being greater than or equal to a char."},"1519":{"dur":3,"text":"This might be strictly greater than, but not positive."},"1523":{"dur":8,"text":"An int is just defined as being greater than or equal to a short."},"1531":{"dur":4,"text":"And a long is just defined as being greater than or equal to an int."},"1536":{"dur":5,"text":"And a long long is greater than or equal to a long."},"1541":{"dur":5,"text":"So the only thing the C standard defines is the relative ordering of everything."},"1546":{"dur":8,"text":"The actual amount of memory that things take up is generally up to implementation,"},"1554":{"dur":2,"text":"but it's pretty well defined at this point. >>[student] Okay."},"1557":{"dur":4,"text":"So shorts are almost always going to be 2 bytes."},"1564":{"dur":5,"text":"Ints are almost always going to be 4 bytes."},"1572":{"dur":3,"text":"Long longs are almost always going to be 8 bytes."},"1577":{"dur":5,"text":"And longs, it depends on whether you're using a 32-bit or a 64-bit system."},"1583":{"dur":4,"text":"So a long is going to correspond to the type of system."},"1587":{"dur":4,"text":"If you're using a 32-bit system like the Appliance, it's going to be 4 bytes."},"1594":{"dur":8,"text":"If you're using a 64-bit like a lot of recent computers, it's going to be 8 bytes."},"1602":{"dur":2,"text":"Ints are almost always 4 bytes at this point."},"1605":{"dur":1,"text":"Long longs are almost always 8 bytes."},"1607":{"dur":3,"text":"In the past, ints used to only be 2 bytes."},"1610":{"dur":6,"text":"But notice that this completely satisfies all of these relations of greater than and equal to."},"1616":{"dur":4,"text":"So long is perfectly allowed to be the same size as an integer,"},"1621":{"dur":2,"text":"and it's also allowed to be the same size as a long long."},"1624":{"dur":7,"text":"And it just so happens to be that in 99.999% of systems, it is going to be equal to"},"1631":{"dur":4,"text":"either an int or a long long. It just depends on 32-bit or 64-bit. >>[student] Okay."},"1635":{"dur":8,"text":"In floats, how is the decimal point designated in terms of bits?"},"1644":{"dur":2,"text":"Like as binary? >>Yeah."},"1647":{"dur":3,"text":"You do not need to know that for CS50."},"1650":{"dur":2,"text":"You don't even learn that in 61."},"1652":{"dur":4,"text":"You don't learn that really in any course."},"1657":{"dur":5,"text":"It's just a representation."},"1662":{"dur":2,"text":"I forget the exact bit allotments."},"1665":{"dur":7,"text":"The idea of floating point is that you allocate a specific number of bits to represent--"},"1673":{"dur":3,"text":"Basically, everything is in scientific notation."},"1676":{"dur":9,"text":"So you allocate a specific number of bits to represent the number itself, like 1.2345."},"1685":{"dur":4,"text":"I can never represent a number with more digits than 5."},"1692":{"dur":14,"text":"Then you also allocate a specific number of bits so that it tends to be like"},"1706":{"dur":6,"text":"you can only go up to a certain number, like that's the largest exponent you can have,"},"1712":{"dur":3,"text":"and you can only go down to a certain exponent,"},"1716":{"dur":2,"text":"like that's the smallest exponent you can have."},"1718":{"dur":5,"text":"I don't remember the exact way bits are assigned to all of these values,"},"1724":{"dur":3,"text":"but a certain number of bits are dedicated to 1.2345,"},"1727":{"dur":2,"text":"another certain number of bits are dedicated to the exponent,"},"1730":{"dur":4,"text":"and it's only possible to represent an exponent of a certain size."},"1735":{"dur":5,"text":"[student] And a double? Is that like an extra long float? >>Yeah."},"1741":{"dur":6,"text":"It's the same thing as a float except now you're using 8 bytes instead of 4 bytes."},"1747":{"dur":4,"text":"Now you'll be able to use 9 digits or 10 digits,"},"1751":{"dur":4,"text":"and this will be able to go up to 300 instead of 100. >>[student] Okay."},"1756":{"dur":4,"text":"And floats are also 4 bytes. >>Yes."},"1761":{"dur":5,"text":"Well, again, it probably depends overall on general implementation,"},"1767":{"dur":3,"text":"but floats are 4 bytes, doubles are 8."},"1770":{"dur":2,"text":"Doubles are called double because they are double the size of floats."},"1773":{"dur":4,"text":"[student] Okay. And are there double doubles? >>There are not."},"1778":{"dur":5,"text":"I think-- >>[student] Like long longs? >>Yeah. I don't think so. Yes."},"1783":{"dur":2,"text":"[student] On last year's test there was a question about the main function"},"1785":{"dur":3,"text":"having to be part of your program."},"1789":{"dur":2,"text":"The answer was that it doesn't have to be part of your program."},"1792":{"dur":2,"text":"In what situation? That's what I saw."},"1795":{"dur":3,"text":"[Bowden] It seems-- >>[student] What situation?"},"1799":{"dur":3,"text":"Do you have the problem? >>[student] Yeah, I can definitely pull it up."},"1802":{"dur":5,"text":"It doesn't have to be, technically, but basically it's going to be."},"1807":{"dur":2,"text":"[student] I saw one on a different year's."},"1810":{"dur":6,"text":"It was like True or False: A valid-- >>Oh, a .c file?"},"1816":{"dur":2,"text":"[student] Any .c file must have-- [both speaking at once - unintelligible]"},"1818":{"dur":2,"text":"Okay. So that's separate."},"1821":{"dur":5,"text":"A .c file just needs to contain functions."},"1826":{"dur":5,"text":"You can compile a file into machine code, binary, whatever,"},"1832":{"dur":4,"text":"without it being executable yet."},"1836":{"dur":2,"text":"A valid executable must have a main function."},"1839":{"dur":6,"text":"You can write 100 functions in 1 file but no main"},"1845":{"dur":3,"text":"and then compile that down to binary,"},"1848":{"dur":5,"text":"then you write another file that only has main but it calls a bunch of these functions"},"1854":{"dur":2,"text":"in this binary file over here."},"1856":{"dur":4,"text":"And so when you're making the executable, that's what the linker does"},"1861":{"dur":4,"text":"is it combines these 2 binary files into an executable."},"1865":{"dur":5,"text":"So a .c file does not need to have a main function at all."},"1871":{"dur":7,"text":"And on big code bases you'll see thousands of .c files and 1 main file."},"1883":{"dur":2,"text":"More questions?"},"1889":{"dur":2,"text":"[student] There was another question."},"1891":{"dur":4,"text":"It said make is a compiler. True or False?"},"1896":{"dur":5,"text":"And the answer was false, and I understood why it's not like Clang."},"1902":{"dur":2,"text":"But what do we call make if it's not?"},"1904":{"dur":5,"text":"Make is basically just-- I can see exactly what it calls it."},"1909":{"dur":2,"text":"But it just runs commands."},"1913":{"dur":2,"text":"Make."},"1918":{"dur":2,"text":"I can pull this up. Yeah."},"1930":{"dur":3,"text":"Oh, yeah. Make also does that."},"1933":{"dur":3,"text":"This says the purpose of the make utility is to determine automatically"},"1937":{"dur":2,"text":"which pieces of a large program need to be recompiled"},"1939":{"dur":2,"text":"and issue the commands to recompile them."},"1942":{"dur":5,"text":"You can make make files that are absolutely huge."},"1947":{"dur":5,"text":"Make looks at the time stamps of files and, like we said before,"},"1953":{"dur":3,"text":"you can compile individual files down, and it's not until you get to the linker"},"1956":{"dur":2,"text":"that they're put together into an executable."},"1959":{"dur":4,"text":"So if you have 10 different files and you make a change to 1 of them,"},"1963":{"dur":4,"text":"then what make is going to do is just recompile that 1 file"},"1967":{"dur":2,"text":"and then relink everything together."},"1970":{"dur":2,"text":"But it's much dumber than that."},"1973":{"dur":2,"text":"It's up to you to completely define that that's what it should be doing."},"1975":{"dur":3,"text":"It by default has the ability to recognize this time stamp stuff,"},"1979":{"dur":3,"text":"but you can write a make file to do anything."},"1983":{"dur":5,"text":"You can write a make file so that when you type make it just cd's to another directory."},"1989":{"dur":6,"text":"I was getting frustrated because I tack everything inside of my Appliance"},"1995":{"dur":6,"text":"and then I view the PDF from the Mac."},"2001":{"dur":8,"text":"So I go to Finder and I can do Go, Connect to Server,"},"2010":{"dur":6,"text":"and the server I connect to is my Appliance, and then I open up the PDF"},"2016":{"dur":3,"text":"that gets compiled by LaTeX."},"2020":{"dur":9,"text":"But I was getting frustrated because every single time I needed to refresh the PDF,"},"2029":{"dur":4,"text":"I had to copy it to a specific directory that it could access"},"2033":{"dur":3,"text":"and it was getting annoying."},"2037":{"dur":4,"text":"So instead I wrote a make file, which you have to define how it makes things."},"2042":{"dur":3,"text":"How you make in this is PDF LaTeX."},"2046":{"dur":3,"text":"Just like any other make file--or I guess you haven't seen the make files,"},"2050":{"dur":3,"text":"but we have in the Appliance a global make file that just says,"},"2053":{"dur":3,"text":"if you are compiling a C file, use Clang."},"2056":{"dur":4,"text":"And so here in my make file that I make I say,"},"2060":{"dur":4,"text":"this file you're going to want to compile with PDF LaTeX."},"2065":{"dur":2,"text":"And so it's PDF LaTeX that's doing the compiling."},"2067":{"dur":3,"text":"Make is not compiling. It's just running these commands in the sequence I specified."},"2071":{"dur":4,"text":"So it runs PDF LaTeX, it copies it to the directory I want it to be copied to,"},"2076":{"dur":2,"text":"it cd's to the directory and does other things,"},"2078":{"dur":4,"text":"but all it does is recognize when a file changes,"},"2082":{"dur":3,"text":"and if it changes, then it will run the commands that it's supposed to run"},"2085":{"dur":3,"text":"when the file changes. >>[student] Okay."},"2090":{"dur":3,"text":"I don't know where the global make files are for me to check it out."},"2097":{"dur":7,"text":"Other questions? Anything from past quizzes? Any pointer things?"},"2106":{"dur":2,"text":"There are subtle things with pointers like--"},"2108":{"dur":1,"text":"I'm not going to be able to find a quiz question on it--"},"2110":{"dur":6,"text":"but just like this sort of thing."},"2119":{"dur":4,"text":"Make sure you understand that when I say int *x *y--"},"2124":{"dur":3,"text":"This isn't exactly anything here, I guess."},"2128":{"dur":4,"text":"But like *x *y, those are 2 variables that are on the stack."},"2132":{"dur":5,"text":"When I say x = malloc(sizeof(int)), x is still a variable on the stack,"},"2137":{"dur":3,"text":"malloc is some block over in the heap, and we're having x point to the heap."},"2141":{"dur":2,"text":"So something on the stack points to the heap."},"2143":{"dur":4,"text":"Whenever you malloc anything, you're inevitably storing it inside of a pointer."},"2148":{"dur":7,"text":"So that pointer is on the stack, the malloced block is on the heap."},"2155":{"dur":5,"text":"A lot of people get confused and say int *x = malloc; x is on the heap."},"2161":{"dur":2,"text":"No. What x points to is on the heap."},"2164":{"dur":4,"text":"x itself is on the stack, unless for whatever reason you have x be a global variable,"},"2168":{"dur":3,"text":"in which case it happens to be in another region of memory."},"2173":{"dur":7,"text":"So keeping track, these box and arrow diagrams are pretty common for the quiz."},"2180":{"dur":4,"text":"Or if it's not on quiz 0, it will be on quiz 1."},"2187":{"dur":4,"text":"You should know all of these, the steps in compiling"},"2191":{"dur":3,"text":"since you had to answer questions on those. Yes."},"2195":{"dur":3,"text":"[student] Could we go over those steps-- >>Sure."},"2208":{"dur":10,"text":"Before steps and compiling we have preprocessing,"},"2218":{"dur":18,"text":"compiling, assembling, and linking."},"2236":{"dur":4,"text":"Preprocessing. What does that do?"},"2249":{"dur":2,"text":"It is the easiest step in--well, not like--"},"2252":{"dur":3,"text":"that doesn't mean it should be obvious, but it's the easiest step."},"2255":{"dur":2,"text":"You guys could implement it yourselves. Yeah."},"2258":{"dur":5,"text":"[student] Take what you have in your includes like this and it copies and then also defines."},"2263":{"dur":5,"text":"It looks for things like #include and #define,"},"2269":{"dur":4,"text":"and it just copies and pastes what those actually mean."},"2273":{"dur":5,"text":"So when you say #include cs50.h, the preprocessor is copying and pasting cs50.h"},"2279":{"dur":1,"text":"into that line."},"2281":{"dur":5,"text":"When you say #define x to be 4, the preprocessor goes through the entire program"},"2286":{"dur":3,"text":"and replaces all instances of x with 4."},"2290":{"dur":7,"text":"So the preprocessor takes a valid C file and outputs a valid C file"},"2297":{"dur":2,"text":"where things have been copied and pasted."},"2300":{"dur":3,"text":"So now compiling. What does that do?"},"2305":{"dur":2,"text":"[student] It goes from C to binary."},"2308":{"dur":2,"text":"[Bowden] It doesn't go all the way to binary."},"2310":{"dur":3,"text":"[student] To machine code then? >>It's not machine code."},"2314":{"dur":1,"text":"[student] Assembly? >>Assembly."},"2315":{"dur":3,"text":"It goes to Assembly before it goes all the way to C code,"},"2318":{"dur":6,"text":"and most languages do something like this."},"2327":{"dur":2,"text":"Pick any high-level language, and if you're going to compile it,"},"2330":{"dur":1,"text":"it's likely to compile in steps."},"2332":{"dur":5,"text":"First it's going to compile Python to C, then it's going to compile C to Assembly,"},"2338":{"dur":3,"text":"and then Assembly is going to get translated to binary."},"2341":{"dur":6,"text":"So compiling is going to bring it from C to Assembly."},"2347":{"dur":4,"text":"The word compiling usually means bringing it from a higher level"},"2352":{"dur":2,"text":"to a lower level programming language."},"2354":{"dur":4,"text":"So this is the only step in compilation where you start with a high-level language"},"2359":{"dur":4,"text":"and end up in a low-level language, and that's why the step is called compiling."},"2365":{"dur":8,"text":"[student] During compiling, let's say that you've done #include cs50.h."},"2373":{"dur":8,"text":"Will the compiler recompile the cs50.h, like the functions that are in there,"},"2382":{"dur":3,"text":"and translate that into Assembly code as well,"},"2385":{"dur":5,"text":"or will it copy and paste something that's been pre-Assembly?"},"2390":{"dur":6,"text":"cs50.h will pretty much never end up in Assembly."},"2399":{"dur":3,"text":"Stuff like function prototypes and things are just for you to be careful."},"2403":{"dur":5,"text":"It guarantees that the compiler can check things like you're calling functions"},"2409":{"dur":3,"text":"with the right return types and the right arguments and stuff."},"2412":{"dur":5,"text":"So cs50.h will be preprocessed into the file, and then when it's compiling"},"2418":{"dur":3,"text":"it's basically thrown away after it makes sure that everything is being called correctly."},"2422":{"dur":7,"text":"But the functions defined in the CS50 library, which are separate from cs50.h,"},"2429":{"dur":4,"text":"those will not be separately compiled."},"2433":{"dur":3,"text":"That will actually come down in the linking step, so we'll get to that in a second."},"2437":{"dur":2,"text":"But first, what is assembling?"},"2441":{"dur":2,"text":"[student] Assembly to binary? >>Yeah."},"2446":{"dur":1,"text":"Assembling."},"2448":{"dur":6,"text":"We don't call it compiling because Assembly is pretty much a pure translation of binary."},"2454":{"dur":5,"text":"There is very little logic in going from Assembly to binary."},"2460":{"dur":2,"text":"It's just like looking up in a table, oh, we have this instruction;"},"2463":{"dur":3,"text":"that corresponds to binary 01110."},"2470":{"dur":5,"text":"And so the files that assembling generally outputs are .o files."},"2475":{"dur":3,"text":"And .o files are what we were saying before,"},"2479":{"dur":2,"text":"how a file does not need to have a main function."},"2481":{"dur":6,"text":"Any file can be compiled down to a .o file as long as it's a valid C file."},"2487":{"dur":2,"text":"It can be compiled down to .o."},"2490":{"dur":12,"text":"Now, linking is what actually brings a bunch of .o files and brings them to an executable."},"2503":{"dur":8,"text":"And so what linking does is you can think of the CS50 library as a .o file."},"2511":{"dur":5,"text":"It is an already compiled binary file."},"2516":{"dur":6,"text":"And so when you compile your file, your hello.c, which calls GetString,"},"2523":{"dur":2,"text":"hello.c gets compiled down to hello.o,"},"2526":{"dur":2,"text":"hello.o is now in binary."},"2528":{"dur":3,"text":"It uses GetString, so it needs to go over to cs50.o,"},"2532":{"dur":3,"text":"and the linker smooshes them together and copies GetString into this file"},"2536":{"dur":4,"text":"and comes out with an executable that has all functions it needs."},"2540":{"dur":11,"text":"So cs50.o isn't actually an O file, but it's close enough that there is no fundamental difference."},"2552":{"dur":4,"text":"So linking just brings a bunch of files together"},"2556":{"dur":4,"text":"that separately contain all of the functions I need to use"},"2561":{"dur":4,"text":"and creates the executable that will actually run."},"2568":{"dur":2,"text":"And so that's also what we were saying before"},"2570":{"dur":5,"text":"where you can have 1000 .c files, you compile them all to .o files,"},"2575":{"dur":4,"text":"which will probably take a while, then you change 1 .c file."},"2580":{"dur":5,"text":"You only need to recompile that 1 .c file and then relink everything else,"},"2585":{"dur":2,"text":"link everything back together."},"2589":{"dur":1,"text":"[student] When we're linking we write lcs50?"},"2591":{"dur":9,"text":"Yeah, so -lcs50. That flag signals to the linker that you should be linking in that library."},"2606":{"dur":2,"text":"Questions?"},"2621":{"dur":5,"text":"Have we gone over binary other than that 5 seconds in the first lecture?"},"2630":{"dur":2,"text":"I don't think so."},"2635":{"dur":3,"text":"You should know all of the big Os that we've gone over,"},"2638":{"dur":3,"text":"and you should be able to, if we gave you a function,"},"2642":{"dur":6,"text":"you should be able to say it's big O, roughly. Or well, big O is rough."},"2649":{"dur":5,"text":"So if you see nested for loops looping over the same number of things,"},"2655":{"dur":6,"text":"like int i, i < n; int j, j < n-- >>[student] n squared. >>it tends to be n squared."},"2662":{"dur":3,"text":"If you have triple nested, it tends to be n cubed."},"2665":{"dur":4,"text":"So that sort of thing you should be able to point out immediately."},"2669":{"dur":4,"text":"You need to know insertion sort and bubble sort and merge sort and all of those."},"2673":{"dur":7,"text":"It's easier to understand why they are those n squared and n log n and all of that"},"2681":{"dur":6,"text":"because I think there was on a quiz one year where we basically gave you"},"2687":{"dur":7,"text":"an implementation of bubble sort and said, \"What is the running time of this function?\""},"2695":{"dur":5,"text":"So if you recognize it as bubble sort, then you can immediately say n squared."},"2701":{"dur":4,"text":"But if you just look at it, you don't even need to realize it's bubble sort;"},"2705":{"dur":3,"text":"you can just say this is doing this and this. This is n squared."},"2712":{"dur":2,"text":"[student] Are there any tough examples you can come up with,"},"2714":{"dur":5,"text":"like a similar idea of figuring out?"},"2720":{"dur":4,"text":"I don't think we would give you any tough examples."},"2724":{"dur":5,"text":"The bubble sort thing is about as tough as we would go,"},"2730":{"dur":6,"text":"and even that, as long as you understand that you're iterating over the array"},"2736":{"dur":5,"text":"for each element in the array, which is going to be something that's n squared."},"2745":{"dur":4,"text":"There are general questions, like right here we have-- Oh."},"2755":{"dur":3,"text":"Just the other day, Doug claimed, \"I have invented an algorithm that can sort an array"},"2758":{"dur":3,"text":"\"of n numbers in O(log n) time!\""},"2761":{"dur":3,"text":"So how do we know that's impossible?"},"2764":{"dur":3,"text":"[inaudible student response] >>Yeah."},"2768":{"dur":4,"text":"At the very least, you have to touch each element in the array,"},"2773":{"dur":2,"text":"so it's impossible to sort an array of--"},"2776":{"dur":4,"text":"If everything is in unsorted order, then you're going to be touching everything in the array,"},"2780":{"dur":4,"text":"so it's impossible to do it in less than O of n."},"2787":{"dur":2,"text":"[student] You showed us that example of being able to do it in O of n"},"2790":{"dur":3,"text":"if you use a lot of memory. >>Yeah."},"2793":{"dur":4,"text":"And that's-- I forget what that's-- Is it counting sort?"},"2807":{"dur":3,"text":"Hmm. That is an integer sorting algorithm."},"2819":{"dur":5,"text":"I was looking for the special name for this that I couldn't remember last week."},"2825":{"dur":7,"text":"Yeah. These are the types of sorts that can accomplish things in big O of n."},"2833":{"dur":5,"text":"But there are limitations, like you can only use integers up to a certain number."},"2840":{"dur":3,"text":"Plus if you're trying to sort something that's--"},"2844":{"dur":6,"text":"If your array is 012, -12, 151, 4 million,"},"2850":{"dur":4,"text":"then that single element is going to completely ruin the entire sorting."},"2862":{"dur":1,"text":"Questions?"},"2869":{"dur":9,"text":"[student] If you have a recursive function and it just makes the recursive calls"},"2878":{"dur":3,"text":"within a return statement, that's tail recursive,"},"2882":{"dur":5,"text":"and so would that not use more memory during runtime"},"2887":{"dur":5,"text":"or it would at least use comparable memory as an iterative solution?"},"2892":{"dur":1,"text":"[Bowden] Yes."},"2894":{"dur":5,"text":"It would likely be somewhat slower, but not really."},"2899":{"dur":3,"text":"Tail recursive is pretty good."},"2903":{"dur":9,"text":"Looking again at stack frames, let's say we have main"},"2912":{"dur":10,"text":"and we have int bar(int x) or something."},"2922":{"dur":9,"text":"This isn't a perfect recursive function, but return bar(x - 1)."},"2932":{"dur":5,"text":"So obviously, this is flawed. You need base cases and stuff."},"2937":{"dur":2,"text":"But the idea here is that this is tail recursive,"},"2940":{"dur":5,"text":"which means when main calls bar it's going to get its stack frame."},"2949":{"dur":2,"text":"In this stack frame there's going to be a little block of memory"},"2952":{"dur":5,"text":"that corresponds to its argument x."},"2957":{"dur":8,"text":"And so let's say main happens to call bar(100);"},"2965":{"dur":4,"text":"So x is going to start out as 100."},"2970":{"dur":5,"text":"If the compiler recognizes that this is a tail recursive function,"},"2975":{"dur":2,"text":"then when bar makes its recursive call to bar,"},"2978":{"dur":6,"text":"instead of making a new stack frame, which is where the stack starts growing largely,"},"2985":{"dur":2,"text":"eventually it will run into the heap and then you get segfaults"},"2988":{"dur":3,"text":"because memory starts colliding."},"2991":{"dur":3,"text":"So instead of making its own stack frame, it can realize,"},"2994":{"dur":4,"text":"hey, I never really need to come back to this stack frame,"},"2999":{"dur":8,"text":"so instead I'll just replace this argument with 99 and then start bar all over."},"3008":{"dur":3,"text":"And then it will do it again and it will reach return bar(x - 1),"},"3011":{"dur":5,"text":"and instead of making a new stack frame, it will just replace its current argument with 98"},"3017":{"dur":3,"text":"and then jump back to the very beginning of bar."},"3023":{"dur":6,"text":"Those operations, replacing that 1 value on the stack and jumping back to the beginning,"},"3030":{"dur":2,"text":"are pretty efficient."},"3032":{"dur":9,"text":"So not only is this the same memory usage as a separate function which is iterative"},"3041":{"dur":3,"text":"because you're only using 1 stack frame, but you're not suffering the downsides"},"3045":{"dur":1,"text":"of having to call functions."},"3047":{"dur":3,"text":"Calling functions can be somewhat expensive because it has to do all this setup"},"3050":{"dur":2,"text":"and teardown and all this stuff."},"3052":{"dur":5,"text":"So this tail recursion is good."},"3058":{"dur":3,"text":"[student] Why does it not create new steps?"},"3061":{"dur":1,"text":"Because it realizes it doesn't need to."},"3062":{"dur":4,"text":"The call to bar is just returning the recursive call."},"3067":{"dur":4,"text":"So it doesn't need to do anything with the return value."},"3072":{"dur":2,"text":"It's just going to immediately return it."},"3075":{"dur":5,"text":"So it's just going to replace its own argument and start over."},"3080":{"dur":5,"text":"And also, if you don't have the tail recursive version,"},"3085":{"dur":5,"text":"then you get all these bars where when this bar returns"},"3091":{"dur":4,"text":"it has to return its value to this one, then that bar immediately returns"},"3096":{"dur":3,"text":"and it returns its value to this one, then it's just going to immediately return"},"3099":{"dur":1,"text":"and return its value to this one."},"3101":{"dur":4,"text":"So you're saving this popping all of these things off of the stack"},"3105":{"dur":3,"text":"since the return value is just going to be passed all the way back up anyway."},"3108":{"dur":6,"text":"So why not just replace our argument with the updated argument and start over?"},"3117":{"dur":3,"text":"If the function is not tail recursive, if you do something like--"},"3121":{"dur":6,"text":"[student] if bar(x + 1). >>Yeah."},"3127":{"dur":4,"text":"So if you put it in condition, then you're doing something with the return value."},"3131":{"dur":4,"text":"Or even if you just do return 2 * bar(x - 1)."},"3136":{"dur":7,"text":"So now bar(x - 1) needs to return in order for it to calculate 2 times that value,"},"3143":{"dur":2,"text":"so now it does need its own separate stack frame,"},"3146":{"dur":5,"text":"and now, no matter how hard you try, you're going to need to--"},"3151":{"dur":3,"text":"This isn't tail recursive."},"3154":{"dur":3,"text":"[student] Would I try to bring a recursion to aim for a tail recursion--"},"3157":{"dur":3,"text":"[Bowden] In an ideal world, but in CS50 you don't have to."},"3163":{"dur":5,"text":"In order to get tail recursion, generally, you set up an additional argument"},"3169":{"dur":4,"text":"where bar will take int x into y"},"3173":{"dur":3,"text":"and y corresponds to the ultimate thing you want to return."},"3176":{"dur":6,"text":"So then this you're going to be returning bar(x - 1), 2 * y."},"3183":{"dur":6,"text":"So that's just a high-level how you transform things to be tail recursive."},"3189":{"dur":3,"text":"But the extra argument--"},"3193":{"dur":3,"text":"And then in the end when you reach your base case, you just return y"},"3197":{"dur":5,"text":"because you've been accumulating the entire time the return value that you want."},"3202":{"dur":4,"text":"You kind of have been doing it iteratively but using recursive calls."},"3212":{"dur":2,"text":"Questions?"},"3214":{"dur":4,"text":"[student] Maybe about pointer arithmetic, like when using strings. >>Sure."},"3219":{"dur":3,"text":"Pointer arithmetic."},"3223":{"dur":4,"text":"When using strings it's easy because strings are char stars,"},"3228":{"dur":3,"text":"chars are forever and always a single byte,"},"3231":{"dur":5,"text":"and so pointer arithmetic is equivalent to regular arithmetic when you're dealing with strings."},"3237":{"dur":11,"text":"Let's just say char* s = \"hello\"."},"3248":{"dur":2,"text":"So we have a block in memory."},"3259":{"dur":2,"text":"It needs 6 bytes because you always need the null terminator."},"3262":{"dur":6,"text":"And char* s is going to point to the beginning of this array."},"3268":{"dur":4,"text":"So s points there."},"3272":{"dur":3,"text":"Now, this is basically how any array works,"},"3276":{"dur":4,"text":"regardless of whether it was a return by malloc or whether it's on the stack."},"3280":{"dur":6,"text":"Any array is basically a pointer to the start of the array,"},"3287":{"dur":6,"text":"and then any array operation, any indexing, is just going into that array a certain offset."},"3293":{"dur":11,"text":"So when I say something like s[3]; this is going to s and counting 3 chars in."},"3305":{"dur":7,"text":"So s[3], we have 0, 1, 2, 3, so s[3] is going to refer to this l."},"3312":{"dur":7,"text":"[student] And we could reach the same value by doing s + 3 and then parentheses star?"},"3320":{"dur":2,"text":"Yes."},"3322":{"dur":3,"text":"This is equivalent to *(s + 3);"},"3326":{"dur":5,"text":"and that is forever and always equivalent no matter what you do."},"3331":{"dur":2,"text":"You never need to use the bracket syntax."},"3334":{"dur":3,"text":"You can always use the *(s + 3) syntax."},"3337":{"dur":2,"text":"People tend to like the bracket syntax, though."},"3340":{"dur":3,"text":"[student] So all arrays are actually just pointers."},"3343":{"dur":9,"text":"There is a slight distinction when I say int x[4]; >>[student] Does that create the memory?"},"3353":{"dur":9,"text":"[Bowden] That is going to create 4 ints on the stack, so 16 bytes overall."},"3363":{"dur":2,"text":"It's going to create 16 bytes on the stack."},"3365":{"dur":3,"text":"x isn't stored anywhere."},"3369":{"dur":4,"text":"It is just a symbol referring to the start of the thing."},"3373":{"dur":4,"text":"Because you declared the array inside of this function,"},"3377":{"dur":4,"text":"what the compiler is going to do is just replace all instances of the variable x"},"3382":{"dur":4,"text":"with where it happened to choose to put these 16 bytes."},"3386":{"dur":3,"text":"It can't do that with char* s because s is an actual pointer."},"3390":{"dur":2,"text":"It is free to then point to other things."},"3392":{"dur":3,"text":"x is a constant. You can't have it point to a different array. >>[student] Okay."},"3396":{"dur":7,"text":"But this idea, this indexing, is the same regardless of whether it's a traditional array"},"3403":{"dur":4,"text":"or if it's a pointer to something or if it's a pointer to a malloced array."},"3408":{"dur":11,"text":"And in fact, it is so equivalent that that is also the same thing."},"3419":{"dur":5,"text":"It actually just translates what's inside of the brackets and what's left of the brackets,"},"3425":{"dur":2,"text":"adds them together, and dereferences."},"3427":{"dur":6,"text":"So this is just as valid as *(s + 3) or s[3]."},"3436":{"dur":5,"text":"[student] Can you have pointers pointing to 2-dimensional arrays?"},"3442":{"dur":5,"text":"It's harder. Traditionally, no."},"3447":{"dur":7,"text":"A 2-dimensional array is just a 1-dimensional array with some convenient syntax"},"3454":{"dur":19,"text":"because when I say int x[3][3], this is really just 1 array with 9 values."},"3475":{"dur":7,"text":"And so when I index, the compiler knows what I mean."},"3483":{"dur":10,"text":"If I say x[1][2], it knows I want to go to the second row, so it's going to skip the first 3,"},"3493":{"dur":4,"text":"and then it wants the second thing in that, so it's going to get this one."},"3497":{"dur":3,"text":"But it is still just a single-dimensional array."},"3500":{"dur":3,"text":"And so if I wanted to assign a pointer to that array,"},"3503":{"dur":6,"text":"I would say int *p = x;"},"3509":{"dur":3,"text":"The type of x is just--"},"3513":{"dur":5,"text":"It's rough saying type of x since it is just a symbol and it's not an actual variable,"},"3518":{"dur":1,"text":"but it is just an int *."},"3520":{"dur":4,"text":"x is just a pointer to the start of this. >>[student] Okay."},"3524":{"dur":7,"text":"And so I won't be able to access [1][2]."},"3532":{"dur":5,"text":"I think there is special syntax for declaring a pointer,"},"3538":{"dur":14,"text":"something ridiculous like int (*p[--something absolutely ridiculous. I don't even know."},"3552":{"dur":4,"text":"But there is a syntax for declaring pointers like with parentheses and things."},"3557":{"dur":5,"text":"It may not even let you do that."},"3562":{"dur":3,"text":"I could look back at something that would tell me the truth."},"3566":{"dur":7,"text":"I will look for it later, if there is a syntax for point. But you will never see it."},"3574":{"dur":5,"text":"And even the syntax is so archaic that if you use it, people will be baffled."},"3579":{"dur":3,"text":"Multidimensional arrays are pretty rare as it is."},"3583":{"dur":1,"text":"You pretty much--"},"3584":{"dur":3,"text":"Well, if you're doing matrix things it's not going to be rare,"},"3588":{"dur":8,"text":"but in C you're rarely going to be using multidimensional arrays."},"3597":{"dur":2,"text":"Yeah. >>[student] Let's say you have a really long array."},"3600":{"dur":3,"text":"So in virtual memory it would appear to be all consecutive,"},"3603":{"dur":1,"text":"like the elements right next to each other,"},"3605":{"dur":3,"text":"but in the physical memory, would it be possible for that to be split up? >>Yes."},"3608":{"dur":8,"text":"How virtual memory works is it just separates--"},"3619":{"dur":5,"text":"The unit of allocation is a page, which tends to be 4 kilobytes,"},"3624":{"dur":4,"text":"and so when a process says, hey, I want to use this memory,"},"3629":{"dur":6,"text":"the operating system is going to allocate it 4 kilobytes for that little block of memory."},"3635":{"dur":3,"text":"Even if you only use a single little byte in the entire block of memory,"},"3639":{"dur":3,"text":"the operating system is going to give it the full 4 kilobytes."},"3642":{"dur":6,"text":"So what this means is I could have--let's say this is my stack."},"3649":{"dur":3,"text":"This stack could be separated. My stack could be megabytes and megabytes."},"3653":{"dur":1,"text":"My stack could be huge."},"3655":{"dur":5,"text":"But the stack itself has to be split into individual pages,"},"3660":{"dur":8,"text":"which if we look at over here let's say this is our RAM,"},"3669":{"dur":7,"text":"if I have 2 gigabytes of RAM, this is actual address 0 like the zeroth byte of my RAM,"},"3676":{"dur":5,"text":"and this is 2 gigabytes all the way down here."},"3682":{"dur":5,"text":"So this page might correspond to this block over here."},"3687":{"dur":2,"text":"This page might correspond to this block over here."},"3689":{"dur":2,"text":"This one might correspond to this one over here."},"3691":{"dur":3,"text":"So the operating system is free to assign physical memory"},"3695":{"dur":3,"text":"to any individual page arbitrarily."},"3699":{"dur":6,"text":"And that means that if this border happens to straddle an array,"},"3706":{"dur":3,"text":"an array happens to be left of this and right of this order of a page,"},"3710":{"dur":4,"text":"then that array is going to be split in physical memory."},"3714":{"dur":4,"text":"And then when you quit the program, when the process ends,"},"3719":{"dur":6,"text":"these mappings get erased and then it's free to use these little blocks for other things."},"3734":{"dur":2,"text":"More questions?"},"3737":{"dur":2,"text":"[student] The pointer arithmetic. >>Oh yeah."},"3739":{"dur":8,"text":"Strings were easier, but looking at something like ints,"},"3748":{"dur":6,"text":"so back to int x[4];"},"3755":{"dur":6,"text":"Whether this is an array or whether it's a pointer to a malloced array of 4 integers,"},"3761":{"dur":5,"text":"it's going to be treated the same way."},"3770":{"dur":2,"text":"[student] So arrays are on the heap?"},"3781":{"dur":3,"text":"[Bowden] Arrays are not on the heap. >>[student] Oh."},"3785":{"dur":3,"text":"[Bowden] This type of array tends to be on the stack"},"3788":{"dur":3,"text":"unless you declared it at--ignoring global variables. Don't use global variables."},"3792":{"dur":4,"text":"Inside of a function I say int x[4];"},"3796":{"dur":6,"text":"It's going to create a 4-integer block on the stack for this array."},"3802":{"dur":4,"text":"But this malloc(4 * sizeof(int)); is going to go on the heap."},"3806":{"dur":4,"text":"But after this point I can use x and p in pretty much the same ways,"},"3811":{"dur":4,"text":"other than the exceptions I said before about you can reassign p."},"3816":{"dur":4,"text":"Technically, their sizes are somewhat different, but that's completely irrelevant."},"3820":{"dur":2,"text":"You never actually use their sizes."},"3828":{"dur":8,"text":"The p I could say p[3] = 2; or x[3] = 2;"},"3836":{"dur":2,"text":"You can use them in exactly the same ways."},"3839":{"dur":1,"text":"So pointer arithmetic now-- Yes."},"3841":{"dur":5,"text":"[student] Do you not have to do p* if you have the brackets?"},"3847":{"dur":4,"text":"The brackets are an implicit dereference. >>Okay."},"3851":{"dur":8,"text":"Actually, also what you're saying with the can you get multidimensional arrays"},"3860":{"dur":42,"text":"with pointers, what you can do is something like, let's say, int **pp = malloc(sizeof(int*) * 5);"},"3902":{"dur":4,"text":"I'll just write it all out first."},"3937":{"dur":3,"text":"I did not want that one."},"3941":{"dur":1,"text":"Okay."},"3942":{"dur":6,"text":"What I did here is-- That should be pp[i]."},"3948":{"dur":4,"text":"So pp is a pointer to a pointer."},"3953":{"dur":8,"text":"You're mallocing pp to point to an array of 5 int stars."},"3962":{"dur":8,"text":"So in memory you have on the stack pp."},"3970":{"dur":9,"text":"It's going to point to an array of 5 blocks which are all themselves pointers."},"3980":{"dur":8,"text":"And then when I malloc down here, I malloc that each of those individual pointers"},"3988":{"dur":3,"text":"should point to a separate block of 4 bytes on the heap."},"3992":{"dur":3,"text":"So this points to 4 bytes."},"3997":{"dur":2,"text":"And this one points to a different 4 bytes."},"4000":{"dur":2,"text":"And all of them point to their own 4 bytes."},"4003":{"dur":5,"text":"This gives me a way of doing multidimensional things."},"4009":{"dur":8,"text":"I could say pp[3][4], but now this is not the same thing as multidimensional arrays"},"4018":{"dur":7,"text":"because multidimensional arrays it translated [3][4] into a single offset into the x array."},"4025":{"dur":9,"text":"This dereferences p, accesses the third index, then dereferences that"},"4034":{"dur":6,"text":"and accesses--4 would be invalid--the second index."},"4044":{"dur":6,"text":"Whereas when we had the int x[3][4] before as a multidimensional array"},"4051":{"dur":4,"text":"and when you double bracket it's really only a single dereference,"},"4055":{"dur":4,"text":"you're following a single pointer and then an offset,"},"4060":{"dur":2,"text":"this is really 2D references."},"4062":{"dur":2,"text":"You follow 2 separate pointers."},"4065":{"dur":4,"text":"So this also technically allows you to have multidimensional arrays"},"4070":{"dur":3,"text":"where each individual array is different sizes."},"4073":{"dur":4,"text":"So I think jagged multidimensional arrays is what it's called"},"4078":{"dur":3,"text":"since really the first thing could point to something that has 10 elements,"},"4081":{"dur":3,"text":"the second thing could point to something that has 100 elements."},"4085":{"dur":5,"text":"[student] Is there any limit to the number of pointers you can have"},"4090":{"dur":3,"text":"pointing to other pointers? >>No."},"4094":{"dur":2,"text":"You can have int *****p."},"4098":{"dur":5,"text":"Back to pointer arithmetic-- >>[student] Oh. >>Yeah."},"4103":{"dur":11,"text":"[student] If I have int ***p and then I do a dereferencing and I say p* is equal to this value,"},"4115":{"dur":3,"text":"is it only going to do 1 level of dereferencing? >>Yes."},"4119":{"dur":3,"text":"So if I want to access the thing that the last pointer is pointing at--"},"4123":{"dur":2,"text":"Then you do ***p. >>Okay."},"4126":{"dur":7,"text":"So this is p points to 1 block, points to another block, points to another block."},"4134":{"dur":7,"text":"Then if you do *p = something else, then you are changing this"},"4142":{"dur":11,"text":"to now point to a different block. >>Okay."},"4153":{"dur":4,"text":"[Bowden] And if these were malloced, then you have now leaked memory"},"4157":{"dur":2,"text":"unless you happen to have different references of these"},"4160":{"dur":4,"text":"since you can't get back to those ones that you just threw away."},"4165":{"dur":4,"text":"Pointer arithmetic."},"4169":{"dur":6,"text":"int x[4]; is going to allocate an array of 4 integers"},"4176":{"dur":4,"text":"where x is going to point to the beginning of the array."},"4180":{"dur":9,"text":"So when I say something like x[1]; I want it to mean go to the second integer in the array,"},"4190":{"dur":2,"text":"which would be this one."},"4193":{"dur":10,"text":"But really, that's 4 bytes into the array since this integer takes up 4 bytes."},"4204":{"dur":4,"text":"So an offset of 1 really means an offset of 1"},"4208":{"dur":3,"text":"times the size of whatever the type of the array is."},"4212":{"dur":5,"text":"This is an array of integers, so it knows to do 1 times size of int when it wants to offset."},"4217":{"dur":8,"text":"The other syntax. Remember that this is equivalent to *(x + 1);"},"4225":{"dur":9,"text":"When I say pointer + 1, what that returns is the address that the pointer is storing"},"4235":{"dur":5,"text":"plus 1 times the size of the type of the pointer."},"4240":{"dur":19,"text":"So if x = ox100, then x + 1 = ox104."},"4259":{"dur":20,"text":"And you can abuse this and say something like char* c = (char*)x;"},"4279":{"dur":3,"text":"and now c is going to be the same address as x."},"4283":{"dur":2,"text":"c is going to be equal to ox100,"},"4286":{"dur":5,"text":"but c + 1 is going to be equal to ox101"},"4291":{"dur":6,"text":"since pointer arithmetic depends on the type of the pointer that you are adding to."},"4298":{"dur":7,"text":"So c + 1, it looks at c, it's a char pointer, so it's going to add 1 times size of char,"},"4305":{"dur":2,"text":"which is always going to be 1, so you get 101,"},"4308":{"dur":6,"text":"whereas if I do x, which is also still 100, x + 1 is going to be 104."},"4316":{"dur":9,"text":"[student] Can you use c++ in order to advance your pointer by 1?"},"4326":{"dur":3,"text":"Yes, you can."},"4329":{"dur":6,"text":"You can't do that with x because x is just a symbol, it is a constant; you can't change x."},"4336":{"dur":6,"text":"But c happens to just be a pointer, so c++ is perfectly valid and it will increment by 1."},"4342":{"dur":9,"text":"If c were just an int *, then c++ would be 104."},"4352":{"dur":8,"text":"++ does pointer arithmetic just as c + 1 would have done pointer arithmetic."},"4363":{"dur":5,"text":"This is actually how a lot of things like merge sort--"},"4369":{"dur":6,"text":"Instead of creating copies of things, you can instead pass--"},"4375":{"dur":6,"text":"Like if I wanted to pass this half of the array--let's erase some of this."},"4384":{"dur":5,"text":"Let's say I wanted to pass this side of the array into a function."},"4390":{"dur":2,"text":"What would I pass to that function?"},"4392":{"dur":4,"text":"If I pass x, I am passing this address."},"4397":{"dur":6,"text":"But I want to pass this particular address. So what should I pass?"},"4403":{"dur":2,"text":"[student] Pointer + 2?"},"4406":{"dur":2,"text":"[Bowden] So x + 2. Yes."},"4409":{"dur":2,"text":"That's going to be this address."},"4411":{"dur":11,"text":"You'll also very frequently see it as x[2] and then the address of that."},"4422":{"dur":5,"text":"So you need to take the address of it because the bracket is an implicit dereference."},"4427":{"dur":5,"text":"x[2] refers to the value that is in this box, and then you want the address of that box,"},"4433":{"dur":3,"text":"so you say &x[2]."},"4436":{"dur":6,"text":"So that's how something in merge sort where you want to pass half the list to something"},"4442":{"dur":5,"text":"you really just pass &x[2], and now as far as the recursive call is concerned,"},"4448":{"dur":3,"text":"my new array starts there."},"4452":{"dur":2,"text":"Last minute questions."},"4455":{"dur":4,"text":"[student] If we don't put an ampersand or a--what's that called? >>Star?"},"4460":{"dur":3,"text":"[student] Star. >>Technically, dereference operator, but-- >>[student] Dereference."},"4463":{"dur":6,"text":"If we don't put a star or an ampersand, what happens if I just say y = x and x is a pointer?"},"4469":{"dur":5,"text":"What is the type of y? >>[student] I'll just say it's pointer 2."},"4474":{"dur":3,"text":"So if you just say y = x, now x and y point to the same thing. >>[student] Point to the same thing."},"4478":{"dur":6,"text":"And if x is an int pointer? >>It would complain because you can't assign pointers."},"4485":{"dur":1,"text":"[student] Okay."},"4486":{"dur":5,"text":"Remember that pointers, even though we draw them as arrows,"},"4491":{"dur":10,"text":"really all they store--int *x--really all x is storing is something like ox100,"},"4502":{"dur":4,"text":"which we happen to represent as pointing to the block stored at 100."},"4506":{"dur":13,"text":"So when I say int *y = x; I'm just copying ox100 into y,"},"4519":{"dur":4,"text":"which we're just going to represent as y, also pointing to ox100."},"4524":{"dur":15,"text":"And if I say int i = (int)x; then i is going to store whatever the value of ox100 is"},"4539":{"dur":5,"text":"inside of it, but now it's going to be interpreted as an integer instead of a pointer."},"4545":{"dur":4,"text":"But you need the cast or else it will complain."},"4549":{"dur":3,"text":"[student] So do you mean to cast--"},"4553":{"dur":6,"text":"Is it going to be casting int of x or casting int of y?"},"4560":{"dur":3,"text":"[Bowden] What?"},"4563":{"dur":3,"text":"[student] Okay. After these parentheses is there going to be an x or a y there?"},"4567":{"dur":3,"text":"[Bowden] Either. x and y are equivalent. >>[student] Okay."},"4571":{"dur":2,"text":"Because they're both pointers. >>Yeah."},"4574":{"dur":6,"text":"[student] So it would store the hexadecimal 100 in integer form? >>[Bowden] Yeah."},"4581":{"dur":2,"text":"But not the value of whatever it points to."},"4583":{"dur":6,"text":"[Bowden] Yeah. >>[student] So just the address in integer form. Okay."},"4589":{"dur":4,"text":"[Bowden] If you wanted to for some bizarre reason,"},"4594":{"dur":4,"text":"you could exclusively deal with pointers and never deal with integers"},"4598":{"dur":10,"text":"and just be like int *x = 0."},"4609":{"dur":3,"text":"Then you're going to get really confused once pointer arithmetic starts happening."},"4613":{"dur":3,"text":"So the numbers that they store are meaningless."},"4616":{"dur":2,"text":"It's just how you end up interpreting them."},"4618":{"dur":3,"text":"So I'm free to copy ox100 from an int * to an int,"},"4622":{"dur":4,"text":"and I'm free to assign--you're probably going to get yelled at for not casting--"},"4627":{"dur":10,"text":"I'm free to assign something like (int *)ox1234 into this arbitrary int *."},"4638":{"dur":7,"text":"So ox123 is just as valid a memory address as is &y."},"4645":{"dur":6,"text":"&y happens to return something that is pretty much ox123."},"4652":{"dur":3,"text":"[student] Would that be a really cool way to go from hexadecimal to decimal form,"},"4655":{"dur":3,"text":"like if you have a pointer and you cast it as an int?"},"4659":{"dur":5,"text":"[Bowden] You can really just print using like printf."},"4664":{"dur":5,"text":"Let's say I have int y = 100."},"4670":{"dur":12,"text":"So printf(%d\\n--as you should already know--print that as an integer, %x."},"4682":{"dur":2,"text":"We'll just print it as hexadecimal."},"4685":{"dur":5,"text":"So a pointer is not stored as hexadecimal,"},"4690":{"dur":2,"text":"and an integer is not stored as decimal."},"4692":{"dur":1,"text":"Everything is stored as binary."},"4694":{"dur":3,"text":"It's just that we tend to show pointers as hexadecimal"},"4697":{"dur":5,"text":"because we think of things in these 4-byte blocks,"},"4703":{"dur":2,"text":"and memory addresses tend to be familiar."},"4705":{"dur":3,"text":"We're like, if it starts with bf, then it happens to be on the stack."},"4708":{"dur":6,"text":"So it's just our interpretation of pointers as hexadecimal."},"4715":{"dur":3,"text":"Okay. Any last questions?"},"4719":{"dur":2,"text":"I'll be here for a bit after if you have anything else."},"4721":{"dur":4,"text":"And that's the end of that."},"4726":{"dur":2,"text":"[student] Yay! [applause]"},"4731":{"dur":1,"text":"[CS50.TV]"}}