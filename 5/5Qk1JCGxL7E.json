{"0.00":{"start":"0","dur":"2.52","text":"[Section 4 - More Comfortable]"},"2.52":{"start":"2.52","dur":"2.33","text":"[Rob Bowden - Harvard University]"},"4.85":{"start":"4.85","dur":"2.52","text":"[This is CS50. - CS50.TV]"},"8.92":{"start":"8.92","dur":"4.43","text":"We have a quiz tomorrow, in case you guys didn&#39;t know that."},"14.81":{"start":"14.81","dur":"6.16","text":"It&#39;s basically on everything you could have seen in class or should have seen in class."},"20.97":{"start":"20.97","dur":"5.39","text":"That includes pointers, even though they&#39;re a very recent topic."},"26.36":{"start":"26.36","dur":"3.5","text":"You should at least understand the high levels of them."},"29.86":{"start":"29.86","dur":"4.9","text":"Anything that was gone over in class you should understand for the quiz."},"34.76":{"start":"34.76","dur":"2.56","text":"So if you have questions on them, you can ask them now."},"37.32":{"start":"37.32","dur":"5.96","text":"But this is going to be a very student-led session where you guys ask questions,"},"43.28":{"start":"43.28","dur":"1.78","text":"so hopefully people have questions."},"45.06":{"start":"45.06","dur":"2.96","text":"Does anyone have questions?"},"49.77":{"start":"49.77","dur":"2.32","text":"Yes. &gt;&gt;[student] Can you go over pointers again?"},"52.09":{"start":"52.09","dur":"2.26","text":"I&#39;ll go over pointers."},"54.35":{"start":"54.35","dur":"4.83","text":"All of your variables necessarily live in memory,"},"59.18":{"start":"59.18","dur":"5.27","text":"but usually you don&#39;t worry about that and you just say x + 2 and y + 3"},"64.45":{"start":"64.45","dur":"2.63","text":"and the compiler will figure out where the things are living for you."},"67.08":{"start":"67.08","dur":"5.91","text":"Once you&#39;re dealing with pointers, now you&#39;re explicitly using those memory addresses."},"72.99":{"start":"72.99","dur":"6.81","text":"So a single variable will only ever live at a single address at any given time."},"79.80":{"start":"79.8","dur":"4.24","text":"If we want to declare a pointer, what is the type going to look like?"},"84.04":{"start":"84.04","dur":"2.17","text":"I want to declare a pointer p. What does the type look like?"},"86.21":{"start":"86.21","dur":"7.32","text":"[student] int *p. &gt;&gt;Yeah. So int *p."},"93.53":{"start":"93.53","dur":"4.5","text":"And how do I make it point to x? &gt;&gt;[student] Ampersand."},"100.54":{"start":"100.54","dur":"4.76","text":"[Bowden] So ampersand is literally called the address of operator."},"105.30":{"start":"105.3","dur":"5.16","text":"So when I say &amp;x it&#39;s getting the memory address of the variable x."},"110.46":{"start":"110.46","dur":"6.33","text":"So now I have the pointer p, and anywhere in my code I can use *p"},"116.79":{"start":"116.79","dur":"6.17","text":"or I could use x and it will be the exact same thing."},"122.96":{"start":"122.96","dur":"6.56","text":"(*p). What is this doing? What does that star mean?"},"129.52":{"start":"129.52","dur":"3.6","text":"[student] It means a value at that point. &gt;&gt;Yeah."},"133.12":{"start":"133.12","dur":"4.47","text":"So if we look at it, it can be very useful to draw out the diagrams"},"137.59":{"start":"137.59","dur":"4.64","text":"where this is a little box of memory for x, which happens to have the value 4,"},"142.23":{"start":"142.23","dur":"3.75","text":"then we have a little box of memory for p,"},"145.98":{"start":"145.98","dur":"5.61","text":"and so p points to x, so we draw an arrow from p to x."},"151.59":{"start":"151.59","dur":"8.68","text":"So when we say *p we&#39;re saying go to the box that is p."},"160.27":{"start":"160.27","dur":"6.21","text":"Star is follow the arrow and then do whatever you want with that box right there."},"166.48":{"start":"166.48","dur":"14.61","text":"So I can say *p = 7; and that will go to the box that is x and change that to 7."},"181.09":{"start":"181.09","dur":"12.45","text":"Or I could say int z = *p * 2; That&#39;s confusing because it&#39;s star, star."},"193.54":{"start":"193.54","dur":"5.69","text":"The one star is dereferencing p, the other star is multiplying by 2."},"199.23":{"start":"199.23","dur":"7.55","text":"Notice I could have just as well replaced the *p with x."},"206.78":{"start":"206.78","dur":"2.65","text":"You can use them in the same way."},"209.43":{"start":"209.43","dur":"8.57","text":"And then later on I can have p point to a completely new thing."},"218.00":{"start":"218","dur":"4.19","text":"I can just say p = &amp;z;"},"222.19":{"start":"222.19","dur":"2.75","text":"So now p no longer points to x; it points to z."},"224.94":{"start":"224.94","dur":"5.57","text":"And any time I do *p it&#39;s the same as doing z."},"230.51":{"start":"230.51","dur":"5.66","text":"So the useful thing about this is once we start getting into functions."},"236.17":{"start":"236.17","dur":"3.62","text":"It&#39;s kind of useless to declare a pointer that points to something"},"239.79":{"start":"239.79","dur":"3.35","text":"and then you&#39;re just dereferencing it"},"243.14":{"start":"243.14","dur":"2.92","text":"when you could have used the original variable to begin with."},"246.06":{"start":"246.06","dur":"12.13","text":"But when you get into functions--so let&#39;s say we have some function, int foo,"},"258.19":{"start":"258.19","dur":"14.62","text":"that takes a pointer and just does *p = 6;"},"272.81":{"start":"272.81","dur":"7.18","text":"Like we saw before with swap, you can&#39;t do an effective swap and a separate function"},"279.99":{"start":"279.99","dur":"5.19","text":"by just passing integers because everything in C is always passing by value."},"285.18":{"start":"285.18","dur":"3.18","text":"Even when you&#39;re passing pointers you&#39;re passing by value."},"288.36":{"start":"288.36","dur":"3.58","text":"It just so happens that those values are memory addresses."},"291.94":{"start":"291.94","dur":"8.83","text":"So when I say foo(p); I&#39;m passing the pointer into the function foo"},"300.77":{"start":"300.77","dur":"3.14","text":"and then foo is doing *p = 6;"},"303.91":{"start":"303.91","dur":"4.69","text":"So inside of that function, *p is still equivalent to x,"},"308.60":{"start":"308.6","dur":"4.12","text":"but I can&#39;t use x inside of that function because it&#39;s not scoped within that function."},"312.72":{"start":"312.72","dur":"6.79","text":"So *p = 6 is the only way I can access a local variable from another function."},"319.51":{"start":"319.51","dur":"4.09","text":"Or, well, pointers are the only way I can access a local variable from another function."},"323.60":{"start":"323.6","dur":"8","text":"[student] Let&#39;s say you wanted to return a pointer. How exactly do you do that?"},"331.60":{"start":"331.6","dur":"12.67","text":"[Bowden] Return a pointer as in something like int y = 3; return &amp;y? &gt;&gt;[student] Yeah."},"344.27":{"start":"344.27","dur":"4.21","text":"[Bowden] Okay. You should never do this. This is bad."},"348.48":{"start":"348.48","dur":"11","text":"I think I saw in these lecture slides you started seeing this whole diagram of memory"},"359.48":{"start":"359.48","dur":"3.4","text":"where up here you&#39;ve got memory address 0"},"362.88":{"start":"362.88","dur":"6.67","text":"and down here you have memory address 4 gigs or 2 to the 32."},"369.55":{"start":"369.55","dur":"5.57","text":"So then you&#39;ve got some stuff and some stuff and then you have your stack"},"375.12":{"start":"375.12","dur":"6.66","text":"and you&#39;ve got your heap, which you just started learning about, growing up."},"381.78":{"start":"381.78","dur":"2.61","text":"[student] Isn&#39;t the heap above the stack?"},"384.39":{"start":"384.39","dur":"3.37","text":"Yeah. The heap is on top, isn&#39;t it? &gt;&gt;[student] Well, he put 0 on top."},"387.76":{"start":"387.76","dur":"2.56","text":"[student] Oh, he put 0 on top. &gt;&gt;[student] Oh, okay."},"390.32":{"start":"390.32","dur":"5.74","text":"Disclaimer: Anywhere with CS50 you&#39;re going to see it this way. &gt;&gt;[student] Okay."},"396.06":{"start":"396.06","dur":"4.23","text":"It&#39;s just that when you&#39;re first seeing stacks,"},"400.29":{"start":"400.29","dur":"4.71","text":"like when you think of a stack you think of stacking things on top of one another."},"405.00":{"start":"405","dur":"5.81","text":"So we tend to flip this around so the stack is growing up like a stack normally would"},"410.81":{"start":"410.81","dur":"5.13","text":"instead of the stack hanging down. &gt;&gt;[student] Don&#39;t heaps technically grow up too, though?"},"415.94":{"start":"415.94","dur":"5.16","text":"It depends on what you mean by grow up."},"421.10":{"start":"421.1","dur":"2.91","text":"The stack and heap always grow in opposite directions."},"424.01":{"start":"424.01","dur":"5.41","text":"A stack is always growing up in the sense that it&#39;s growing up"},"429.42":{"start":"429.42","dur":"3.52","text":"towards higher memory addresses, and the heap is growing down"},"432.94":{"start":"432.94","dur":"4.32","text":"in that it&#39;s growing towards lower memory addresses."},"437.26":{"start":"437.26","dur":"2.99","text":"So the top is 0 and the bottom is high memory addresses."},"440.25":{"start":"440.25","dur":"6.14","text":"They&#39;re both growing, just in opposing directions."},"446.39":{"start":"446.39","dur":"2.84","text":"[student] I just meant that because you said you put stack on the bottom"},"449.23":{"start":"449.23","dur":"4.41","text":"because it seems more intuitive because for the stack to start at the top of a heap,"},"453.64":{"start":"453.64","dur":"3.88","text":"heap&#39;s on top of itself too, so that&#39;s-- &gt;&gt;Yeah."},"457.52":{"start":"457.52","dur":"7.44","text":"You also think of the heap as growing up and larger, but the stack more so."},"464.96":{"start":"464.96","dur":"5.32","text":"So the stack is the one that we kind of want to show growing up."},"470.28":{"start":"470.28","dur":"5.11","text":"But everywhere you look otherwise is going to show address 0 at the top"},"475.39":{"start":"475.39","dur":"4.2","text":"and the highest memory address at the bottom, so this is your usual view of memory."},"479.59":{"start":"479.59","dur":"2.51","text":"Do you have a question?"},"482.10":{"start":"482.1","dur":"2.17","text":"[student] Can you tell us more about the heap?"},"484.27":{"start":"484.27","dur":"1.91","text":"Yeah. I&#39;ll get to that in a second."},"486.18":{"start":"486.18","dur":"6.04","text":"First, going back to why returning &amp;y is a bad thing,"},"492.22":{"start":"492.22","dur":"6.25","text":"on the stack you have a bunch of stack frames which represent all of the functions"},"498.47":{"start":"498.47","dur":"1.99","text":"which have been called."},"500.46":{"start":"500.46","dur":"7.53","text":"So ignoring previous things, the top of your stack is always going to be the main function"},"507.99":{"start":"507.99","dur":"5.1","text":"since that&#39;s the first function that&#39;s being called."},"513.09":{"start":"513.09","dur":"4.04","text":"And then when you call another function, the stack is going to grow down."},"517.13":{"start":"517.13","dur":"4.51","text":"So if I call some function, foo, and it gets its own stack frame,"},"521.64":{"start":"521.64","dur":"5.64","text":"it can call some function, bar; it gets its own stack frame."},"527.28":{"start":"527.28","dur":"2.56","text":"And bar could be recursive and it could call itself,"},"529.84":{"start":"529.84","dur":"4.31","text":"and so that second call to bar is going to get its own stack frame."},"534.15":{"start":"534.15","dur":"4.73","text":"And so what goes in these stack frames are all of the local variables"},"538.88":{"start":"538.88","dur":"4.57","text":"and all of the function arguments that--"},"543.45":{"start":"543.45","dur":"5.28","text":"Any things that are locally scoped to this function go in these stack frames."},"548.73":{"start":"548.73","dur":"12.79","text":"So that means when I said something like bar is a function,"},"561.52":{"start":"561.52","dur":"7.75","text":"I&#39;m just going to declare an integer and then return a pointer to that integer."},"569.27":{"start":"569.27","dur":"4.52","text":"So where does y live?"},"573.79":{"start":"573.79","dur":"3.11","text":"[student] y lives in bar. &gt;&gt;[Bowden] Yeah."},"576.90":{"start":"576.9","dur":"8.11","text":"Somewhere in this little square of memory is a littler square that has y in it."},"585.01":{"start":"585.01","dur":"8.36","text":"When I return &amp;y, I&#39;m returning a pointer to this little block of memory."},"593.37":{"start":"593.37","dur":"5.03","text":"But then when a function returns, its stack frame gets popped off the stack."},"601.05":{"start":"601.05","dur":"2.48","text":"And that&#39;s why it&#39;s called stack."},"603.53":{"start":"603.53","dur":"3.04","text":"It&#39;s like the stack data structure, if you know what that is."},"606.57":{"start":"606.57","dur":"5.01","text":"Or even like a stack of trays is always the example,"},"611.58":{"start":"611.58","dur":"4.48","text":"main is going to go on the bottom, then the first function you call is going to go on top of that,"},"616.06":{"start":"616.06","dur":"4.34","text":"and you can&#39;t get back to main until you return from all functions which have been called"},"620.40":{"start":"620.4","dur":"1.94","text":"that have been placed on top of it."},"622.34":{"start":"622.34","dur":"6.31","text":"[student] So if you did do return the &amp;y, that value is subject to change without notice."},"628.65":{"start":"628.65","dur":"2.64","text":"Yes, it&#39;s-- &gt;&gt;[student] It could be overwritten. &gt;&gt;Yeah."},"631.29":{"start":"631.29","dur":"3.37","text":"It&#39;s completely-- If you try and--"},"634.66":{"start":"634.66","dur":"3.38","text":"This would also be an int *bar because it&#39;s returning a pointer,"},"638.04":{"start":"638.04","dur":"3.27","text":"so its return type is int *."},"641.31":{"start":"641.31","dur":"5.19","text":"If you try to use the return value of this function, it&#39;s undefined behavior"},"646.50":{"start":"646.5","dur":"5.27","text":"because that pointer points to bad memory. &gt;&gt;[student] Okay."},"651.77":{"start":"651.77","dur":"9.48","text":"So what if, for example, you declared int *y = malloc(sizeof(int))?"},"661.25":{"start":"661.25","dur":"2.49","text":"That&#39;s better. Yes."},"663.74":{"start":"663.74","dur":"3.99","text":"[student] We talked about how when we drag things to our recycle bin"},"667.73":{"start":"667.73","dur":"4.02","text":"they&#39;re not actually erased; we just lose their pointers."},"671.75":{"start":"671.75","dur":"3.8","text":"So in this case do we actually erase the value or is it still there in memory?"},"675.55":{"start":"675.55","dur":"3.58","text":"For the most part, it&#39;s going to still be there."},"679.13":{"start":"679.13","dur":"5.09","text":"But let&#39;s say we happen to call some other function, baz."},"684.22":{"start":"684.22","dur":"4.77","text":"Baz is going to get its own stack frame on here."},"688.99":{"start":"688.99","dur":"2.48","text":"It&#39;s going to be overwriting all of this stuff,"},"691.47":{"start":"691.47","dur":"2.71","text":"and then if you later try and use the pointer that you got before,"},"694.18":{"start":"694.18","dur":"1.39","text":"it&#39;s not going to be the same value."},"695.57":{"start":"695.57","dur":"2.58","text":"It&#39;s going to have changed just because you called the function baz."},"698.15":{"start":"698.15","dur":"4.93","text":"[student] But had we not, would we still get 3?"},"703.08":{"start":"703.08","dur":"1.91","text":"[Bowden] In all likelihood, you would."},"704.99":{"start":"704.99","dur":"4.68","text":"But you can&#39;t rely on that. C just says undefined behavior."},"709.67":{"start":"709.67","dur":"2.25","text":"[student] Oh, it does. Okay."},"711.92":{"start":"711.92","dur":"6.27","text":"So when you want to return a pointer, this is where malloc comes in use."},"720.93":{"start":"720.93","dur":"15.03","text":"I&#39;m writing actually just return malloc(3 * sizeof(int))."},"737.36":{"start":"737.36","dur":"6.69","text":"We&#39;ll go over malloc more in a second, but the idea of malloc is all of your local variables"},"744.05":{"start":"744.05","dur":"2.71","text":"always go on the stack."},"746.76":{"start":"746.76","dur":"4.81","text":"Anything that&#39;s malloced goes on the heap, and it will forever and always be on the heap"},"751.57":{"start":"751.57","dur":"2.92","text":"until you explicitly free it."},"754.49":{"start":"754.49","dur":"7.64","text":"So this means that when you malloc something, it&#39;s going to survive after the function returns."},"762.13":{"start":"762.13","dur":"4.67","text":"[student] Will it survive after the program stops running? &gt;&gt;No."},"766.80":{"start":"766.8","dur":"6.38","text":"Okay, so it&#39;s going to be there until the program is all the way done running. &gt;&gt;Yes."},"773.18":{"start":"773.18","dur":"4.33","text":"We can go over details of what happens when the program stops running."},"777.51":{"start":"777.51","dur":"4.64","text":"You might need to remind me, but that is a separate thing entirely."},"782.15":{"start":"782.15","dur":"2.04","text":"[student] So malloc creates a pointer? &gt;&gt;Yeah."},"784.19":{"start":"784.19","dur":"8.84","text":"Malloc-- &gt;&gt;[student] I think malloc designates a block of memory that a pointer can use."},"795.40":{"start":"795.4","dur":"4.21","text":"[Bowden] I want that diagram again. &gt;&gt;[student] So this function works, though?"},"799.61":{"start":"799.61","dur":"6.82","text":"[student] Yeah, malloc designates a block of memory that you can use,"},"806.43":{"start":"806.43","dur":"4.04","text":"and then it returns the address of the first block of that memory."},"810.47":{"start":"810.47","dur":"6.28","text":"[Bowden] Yeah. So when you malloc, you&#39;re grabbing some block of memory"},"816.75":{"start":"816.75","dur":"1.51","text":"that&#39;s currently in the heap."},"818.26":{"start":"818.26","dur":"4.78","text":"If the heap is too small, then the heap is just going to grow, and it grows in this direction."},"823.04":{"start":"823.04","dur":"1.61","text":"So let&#39;s say the heap is too small."},"824.65":{"start":"824.65","dur":"5.31","text":"Then it&#39;s about to grow a little bit and return a pointer to this block that just grew."},"829.96":{"start":"829.96","dur":"5.17","text":"When you free stuff, you&#39;re making more room in the heap,"},"835.13":{"start":"835.13","dur":"4.9","text":"so then a later call to malloc can reuse that memory that you had previously freed."},"840.03":{"start":"840.03","dur":"9.92","text":"The important thing about malloc and free is that it gives you complete control"},"849.95":{"start":"849.95","dur":"2.75","text":"over the lifetime of these memory blocks."},"852.70":{"start":"852.7","dur":"2.72","text":"Global variables are always alive."},"855.42":{"start":"855.42","dur":"3.08","text":"Local variables are alive within their scope."},"858.50":{"start":"858.5","dur":"3.64","text":"As soon as you go past a curly brace, the local variables are dead."},"862.14":{"start":"862.14","dur":"6.75","text":"Malloced memory is alive when you want it to be alive"},"868.89":{"start":"868.89","dur":"4.59","text":"and then is released when you tell it to be released."},"873.48":{"start":"873.48","dur":"4.94","text":"Those are actually the only 3 types of memory, really."},"878.42":{"start":"878.42","dur":"3.42","text":"There&#39;s automatic memory management, which is the stack."},"881.84":{"start":"881.84","dur":"2","text":"Things happen for you automatically."},"883.84":{"start":"883.84","dur":"3.07","text":"When you say int x, memory is allocated for int x."},"886.91":{"start":"886.91","dur":"4.72","text":"When x goes out of scope, memory is reclaimed for x."},"891.63":{"start":"891.63","dur":"3.16","text":"Then there&#39;s dynamic memory management, which is what malloc is,"},"894.79":{"start":"894.79","dur":"1.95","text":"which is when you have control."},"896.74":{"start":"896.74","dur":"4.55","text":"You dynamically decide when memory should and should not be allocated."},"901.29":{"start":"901.29","dur":"3.76","text":"And then there&#39;s static, which just means that it lives forever,"},"905.05":{"start":"905.05","dur":"1.56","text":"which is what global variables are."},"906.61":{"start":"906.61","dur":"3.63","text":"They&#39;re just always in memory."},"910.96":{"start":"910.96","dur":"1.8","text":"Questions?"},"914.49":{"start":"914.49","dur":"2.74","text":"[student] Can you define a block just by using curly braces"},"917.23":{"start":"917.23","dur":"3.99","text":"but not having to have an if statement or a while statement or anything like that?"},"921.22":{"start":"921.22","dur":"7.91","text":"You can define a block as in a function, but that has curly braces too."},"929.13":{"start":"929.13","dur":"2.97","text":"[student] So you can&#39;t just have like a random pair of curly braces in your code"},"932.10":{"start":"932.1","dur":"3.58","text":"that have local variables? &gt;&gt;Yes, you can."},"935.68":{"start":"935.68","dur":"10.22","text":"Inside of int bar we could have {int y = 3;}."},"945.90":{"start":"945.9","dur":"2.54","text":"That&#39;s supposed to be right here."},"948.44":{"start":"948.44","dur":"4.01","text":"But that completely defines the scope of int y."},"952.45":{"start":"952.45","dur":"4.87","text":"After that second curly brace, y cannot be used anymore."},"957.91":{"start":"957.91","dur":"2.72","text":"You almost never do that, though."},"962.94":{"start":"962.94","dur":"4.43","text":"Getting back to what happens when a program ends,"},"967.37":{"start":"967.37","dur":"11.39","text":"there&#39;s kind of a misconception\/half lie that we give in order to just make things easier."},"978.76":{"start":"978.76","dur":"5.65","text":"We tell you that when you allocate memory"},"984.41":{"start":"984.41","dur":"5.45","text":"you&#39;re allocating some chunk of RAM for that variable."},"989.86":{"start":"989.86","dur":"4.33","text":"But you&#39;re not really directly touching RAM ever in your programs."},"994.19":{"start":"994.19","dur":"3.3","text":"If you think of it, how I drew--"},"997.49":{"start":"997.49","dur":"6.84","text":"And actually, if you go through in GDB you&#39;ll see the same thing."},"1011.12":{"start":"1011.12","dur":"6.47","text":"Regardless of how many times you run your program or what program you&#39;re running,"},"1017.59":{"start":"1017.59","dur":"2.36","text":"the stack is always going to start--"},"1019.95":{"start":"1019.95","dur":"6.56","text":"you&#39;re always going to see variables around address oxbffff something."},"1026.51":{"start":"1026.51","dur":"2.96","text":"It&#39;s usually somewhere in that region."},"1029.47":{"start":"1029.47","dur":"9.29","text":"But how can 2 programs possibly have pointers to the same memory?"},"1040.64":{"start":"1040.64","dur":"7.01","text":"[student] There&#39;s some arbitrary designation of where oxbfff is supposed to be on the RAM"},"1047.65":{"start":"1047.65","dur":"3.67","text":"that can actually be in different places depending on when the function was called."},"1051.32":{"start":"1051.32","dur":"4.6","text":"Yeah. The term is virtual memory."},"1055.92":{"start":"1055.92","dur":"6.33","text":"The idea is that every single process, every single program that is running on your computer"},"1062.25":{"start":"1062.25","dur":"7.2","text":"has its own--let&#39;s assume 32 bits--completely independent address space."},"1069.45":{"start":"1069.45","dur":"2.14","text":"This is the address space."},"1071.59":{"start":"1071.59","dur":"4.63","text":"It has its own completely independent 4 gigabytes to use."},"1076.22":{"start":"1076.22","dur":"6","text":"So if you run 2 programs simultaneously, this program sees 4 gigabytes to itself,"},"1082.22":{"start":"1082.22","dur":"2.65","text":"this program sees 4 gigabytes to itself,"},"1084.87":{"start":"1084.87","dur":"2.85","text":"and it&#39;s impossible for this program to dereference a pointer"},"1087.72":{"start":"1087.72","dur":"3.2","text":"and end up with memory from this program."},"1090.92":{"start":"1090.92","dur":"7.28","text":"And what virtual memory is is a mapping from a processes address space"},"1098.20":{"start":"1098.2","dur":"2.27","text":"to actual things on RAM."},"1100.47":{"start":"1100.47","dur":"2.47","text":"So it&#39;s up to your operating system to know that,"},"1102.94":{"start":"1102.94","dur":"5.14","text":"hey, when this guy dereferences pointer oxbfff, that really means"},"1108.08":{"start":"1108.08","dur":"2.96","text":"that he wants RAM byte 1000,"},"1111.04":{"start":"1111.04","dur":"7.11","text":"whereas if this program dereferences oxbfff, he really wants RAM byte 10000."},"1118.15":{"start":"1118.15","dur":"3.44","text":"They can be arbitrarily far apart."},"1121.59":{"start":"1121.59","dur":"7.14","text":"This is even true of things within a single processes address space."},"1128.73":{"start":"1128.73","dur":"6.04","text":"So like it sees all 4 gigabytes to itself, but let&#39;s say--"},"1134.77":{"start":"1134.77","dur":"2.52","text":"[student] Does every single process--"},"1137.29":{"start":"1137.29","dur":"4.06","text":"Let&#39;s say you have a computer with only 4 gigabytes of RAM."},"1141.35":{"start":"1141.35","dur":"5.08","text":"Does every single process see the whole 4 gigabytes? &gt;&gt;Yes."},"1146.43":{"start":"1146.43","dur":"6.63","text":"But the 4 gigabytes it sees is a lie."},"1153.06":{"start":"1153.06","dur":"7.4","text":"It&#39;s just it thinks it has all this memory because it doesn&#39;t know any other process exists."},"1160.46":{"start":"1160.46","dur":"7.68","text":"It will only use as much memory as it actually needs."},"1168.14":{"start":"1168.14","dur":"4.2","text":"The operating system is not going to give RAM to this process"},"1172.34":{"start":"1172.34","dur":"3.41","text":"if it&#39;s not using any memory in this entire region."},"1175.75":{"start":"1175.75","dur":"3.55","text":"It&#39;s not going to give it memory for that region."},"1179.30":{"start":"1179.3","dur":"15.48","text":"But the idea is that-- I&#39;m trying to think of-- I can&#39;t think of an analogy."},"1194.78":{"start":"1194.78","dur":"2","text":"Analogies are hard."},"1197.74":{"start":"1197.74","dur":"4.96","text":"One of the issues of virtual memory or one of the things it&#39;s solving"},"1202.70":{"start":"1202.7","dur":"4.11","text":"is that processes should be completely unaware of one another."},"1206.81":{"start":"1206.81","dur":"5.33","text":"And so you can write any program that just dereferences any pointer,"},"1212.14":{"start":"1212.14","dur":"7.2","text":"like just write a program that says *(ox1234),"},"1219.34":{"start":"1219.34","dur":"3.55","text":"and that&#39;s dereferencing memory address 1234."},"1222.89":{"start":"1222.89","dur":"5.98","text":"But it&#39;s up to the operating system to then translate what 1234 means."},"1228.87":{"start":"1228.87","dur":"5.09","text":"So if 1234 happens to be a valid memory address for this process,"},"1233.96":{"start":"1233.96","dur":"4.84","text":"like it&#39;s on the stack or something, then this will return the value of that memory address"},"1238.80":{"start":"1238.8","dur":"3.16","text":"as far as the process knows."},"1241.96":{"start":"1241.96","dur":"5.56","text":"But if 1234 is not a valid address, like it happens to land"},"1247.52":{"start":"1247.52","dur":"5.39","text":"in some little piece of memory here that is beyond the stack and beyond the heap"},"1252.91":{"start":"1252.91","dur":"4.29","text":"and you haven&#39;t really used that, then that&#39;s when you get things like segfaults"},"1257.20":{"start":"1257.2","dur":"3.06","text":"because you&#39;re touching memory that you should not be touching."},"1267.18":{"start":"1267.18","dur":"2.16","text":"This is also true--"},"1269.34":{"start":"1269.34","dur":"6.1","text":"A 32-bit system, 32 bits means you have 32 bits to define a memory address."},"1275.44":{"start":"1275.44","dur":"7.53","text":"It&#39;s why pointers are 8 bytes because 32 bits are 8 bytes--or 4 bytes."},"1282.97":{"start":"1282.97","dur":"2.28","text":"Pointers are 4 bytes."},"1285.25":{"start":"1285.25","dur":"8.43","text":"So when you see a pointer like oxbfffff, that is--"},"1293.68":{"start":"1293.68","dur":"6.4","text":"Within any given program you can just construct any arbitrary pointer,"},"1300.08":{"start":"1300.08","dur":"6.25","text":"anywhere from ox0 to ox 8 f&#39;s--ffffffff."},"1306.33":{"start":"1306.33","dur":"2.85","text":"[student] Didn&#39;t you say they&#39;re 4 bytes? &gt;&gt;Yeah."},"1309.18":{"start":"1309.18","dur":"3.55","text":"[student] Then each byte will have-- &gt;&gt;[Bowden] Hexadecimal."},"1312.73":{"start":"1312.73","dur":"6.63","text":"Hexadecimal--5, 6, 7, 8. So pointers you&#39;re going to always see in hexadecimal."},"1319.36":{"start":"1319.36","dur":"2.35","text":"It&#39;s just how we classify pointers."},"1321.71":{"start":"1321.71","dur":"3.53","text":"Every 2 digits of hexadecimal is 1 byte."},"1325.24":{"start":"1325.24","dur":"4.36","text":"So there&#39;s going to be 8 hexadecimal digits for 4 bytes."},"1329.60":{"start":"1329.6","dur":"4.59","text":"So every single pointer on a 32-bit system is going to be 4 bytes,"},"1334.19":{"start":"1334.19","dur":"4.36","text":"which means that in your process you can construct any arbitrary 4 bytes"},"1338.55":{"start":"1338.55","dur":"2","text":"and make a pointer out of it,"},"1340.55":{"start":"1340.55","dur":"12.18","text":"which means that as far as it&#39;s aware, it can address an entire 2 to the 32 bytes of memory."},"1352.73":{"start":"1352.73","dur":"2.03","text":"Even though it doesn&#39;t really have access to that,"},"1354.76":{"start":"1354.76","dur":"5.43","text":"even if your computer only has 512 megabytes, it thinks it has that much memory."},"1360.19":{"start":"1360.19","dur":"4.74","text":"And the operating system is smart enough that it will only allocate what you actually need."},"1364.93":{"start":"1364.93","dur":"4.7","text":"It doesn&#39;t just go, oh, a new process: 4 gigs."},"1369.63":{"start":"1369.63","dur":"2.3","text":"Yeah. &gt;&gt;[student] What does the ox mean? Why do you write it?"},"1371.93":{"start":"1371.93","dur":"3.05","text":"It&#39;s just the symbol for hexadecimal."},"1374.98":{"start":"1374.98","dur":"4.61","text":"When you see a number start with ox, the successive things are hexadecimal."},"1381.93":{"start":"1381.93","dur":"3.83","text":"[student] You were explaining about what happens when a program ends. &gt;&gt;Yes."},"1385.76":{"start":"1385.76","dur":"3.72","text":"What happens when a program ends is the operating system"},"1389.48":{"start":"1389.48","dur":"4.12","text":"just erases the mappings that it has for these addresses, and that&#39;s it."},"1393.60":{"start":"1393.6","dur":"4.17","text":"The operating system can now just give that memory to another program to use."},"1397.77":{"start":"1397.77","dur":"1.72","text":"[student] Okay."},"1399.49":{"start":"1399.49","dur":"5.31","text":"So when you allocate something on the heap or the stack or global variables or anything,"},"1404.80":{"start":"1404.8","dur":"2.21","text":"they all just disappear as soon as the program ends"},"1407.01":{"start":"1407.01","dur":"5.11","text":"because the operating system is now free to give that memory to any other process."},"1412.12":{"start":"1412.12","dur":"3.03","text":"[student] Even though there are probably still values written in? &gt;&gt;Yeah."},"1415.15":{"start":"1415.15","dur":"2.59","text":"The values are likely still there."},"1417.74":{"start":"1417.74","dur":"3.83","text":"It&#39;s just it&#39;s going to be difficult to get at them."},"1421.57":{"start":"1421.57","dur":"3.66","text":"It&#39;s much more difficult to get at them than it is to get at a deleted file"},"1425.23":{"start":"1425.23","dur":"6.22","text":"because the deleted file kind of sits there for a long time and the hard drive is a lot bigger."},"1431.45":{"start":"1431.45","dur":"2.67","text":"So it&#39;s going to overwrite different parts of memory"},"1434.12":{"start":"1434.12","dur":"4.52","text":"before it happens to overwrite the chunk of memory that that file used to be at."},"1438.64":{"start":"1438.64","dur":"5.88","text":"But main memory, RAM, you cycle through a lot faster,"},"1444.52":{"start":"1444.52","dur":"3.52","text":"so it&#39;s going to very rapidly be overwritten."},"1450.30":{"start":"1450.3","dur":"3.04","text":"Questions on this or anything else?"},"1453.34":{"start":"1453.34","dur":"2.79","text":"[student] I have questions about a different topic. &gt;&gt;Okay."},"1456.13":{"start":"1456.13","dur":"2.93","text":"Does anyone have questions on this?"},"1460.17":{"start":"1460.17","dur":"2.95","text":"Okay. Different topic. &gt;&gt;[student] Okay."},"1463.12":{"start":"1463.12","dur":"3.43","text":"I was going through some of the practice tests,"},"1466.55":{"start":"1466.55","dur":"3.93","text":"and in one of them it was talking about the sizeof"},"1470.48":{"start":"1470.48","dur":"5.15","text":"and the value that it returns or different variable types. &gt;&gt;Yes."},"1475.63":{"start":"1475.63","dur":"9.43","text":"And it said that both int and long both return 4, so they&#39;re both 4 bytes long."},"1485.06":{"start":"1485.06","dur":"3.01","text":"Is there any difference between an int and a long, or is it the same thing?"},"1488.07":{"start":"1488.07","dur":"2.31","text":"Yes, there is a difference."},"1490.38":{"start":"1490.38","dur":"2.58","text":"The C standard--"},"1492.96":{"start":"1492.96","dur":"1.99","text":"I&#39;m probably going to mess up."},"1494.95":{"start":"1494.95","dur":"3.85","text":"The C standard is just like what C is, the official documentation of C."},"1498.80":{"start":"1498.8","dur":"1.54","text":"This is what it says."},"1500.34":{"start":"1500.34","dur":"8.31","text":"So the C standard just says that a char will forever and always be 1 byte."},"1510.47":{"start":"1510.47","dur":"8.57","text":"Everything after that--a short is always just defined as being greater than or equal to a char."},"1519.04":{"start":"1519.04","dur":"3.97","text":"This might be strictly greater than, but not positive."},"1523.01":{"start":"1523.01","dur":"8.93","text":"An int is just defined as being greater than or equal to a short."},"1531.94":{"start":"1531.94","dur":"4.27","text":"And a long is just defined as being greater than or equal to an int."},"1536.21":{"start":"1536.21","dur":"5.39","text":"And a long long is greater than or equal to a long."},"1541.60":{"start":"1541.6","dur":"5.01","text":"So the only thing the C standard defines is the relative ordering of everything."},"1546.61":{"start":"1546.61","dur":"8.27","text":"The actual amount of memory that things take up is generally up to implementation,"},"1554.88":{"start":"1554.88","dur":"2.76","text":"but it&#39;s pretty well defined at this point. &gt;&gt;[student] Okay."},"1557.64":{"start":"1557.64","dur":"4.85","text":"So shorts are almost always going to be 2 bytes."},"1564.92":{"start":"1564.92","dur":"5.03","text":"Ints are almost always going to be 4 bytes."},"1572.07":{"start":"1572.07","dur":"3.27","text":"Long longs are almost always going to be 8 bytes."},"1577.99":{"start":"1577.99","dur":"5.17","text":"And longs, it depends on whether you&#39;re using a 32-bit or a 64-bit system."},"1583.16":{"start":"1583.16","dur":"4.29","text":"So a long is going to correspond to the type of system."},"1587.45":{"start":"1587.45","dur":"4.47","text":"If you&#39;re using a 32-bit system like the Appliance, it&#39;s going to be 4 bytes."},"1594.53":{"start":"1594.53","dur":"8.04","text":"If you&#39;re using a 64-bit like a lot of recent computers, it&#39;s going to be 8 bytes."},"1602.57":{"start":"1602.57","dur":"2.66","text":"Ints are almost always 4 bytes at this point."},"1605.23":{"start":"1605.23","dur":"1.91","text":"Long longs are almost always 8 bytes."},"1607.14":{"start":"1607.14","dur":"3.16","text":"In the past, ints used to only be 2 bytes."},"1610.30":{"start":"1610.3","dur":"6.54","text":"But notice that this completely satisfies all of these relations of greater than and equal to."},"1616.84":{"start":"1616.84","dur":"4.44","text":"So long is perfectly allowed to be the same size as an integer,"},"1621.28":{"start":"1621.28","dur":"2.75","text":"and it&#39;s also allowed to be the same size as a long long."},"1624.03":{"start":"1624.03","dur":"7.04","text":"And it just so happens to be that in 99.999% of systems, it is going to be equal to"},"1631.07":{"start":"1631.07","dur":"4.73","text":"either an int or a long long. It just depends on 32-bit or 64-bit. &gt;&gt;[student] Okay."},"1635.80":{"start":"1635.8","dur":"8.8","text":"In floats, how is the decimal point designated in terms of bits?"},"1644.60":{"start":"1644.6","dur":"2.56","text":"Like as binary? &gt;&gt;Yeah."},"1647.16":{"start":"1647.16","dur":"3.41","text":"You do not need to know that for CS50."},"1650.57":{"start":"1650.57","dur":"2.39","text":"You don&#39;t even learn that in 61."},"1652.96":{"start":"1652.96","dur":"4.39","text":"You don&#39;t learn that really in any course."},"1657.35":{"start":"1657.35","dur":"5.39","text":"It&#39;s just a representation."},"1662.74":{"start":"1662.74","dur":"2.7","text":"I forget the exact bit allotments."},"1665.44":{"start":"1665.44","dur":"7.94","text":"The idea of floating point is that you allocate a specific number of bits to represent--"},"1673.38":{"start":"1673.38","dur":"3.17","text":"Basically, everything is in scientific notation."},"1676.55":{"start":"1676.55","dur":"9.05","text":"So you allocate a specific number of bits to represent the number itself, like 1.2345."},"1685.60":{"start":"1685.6","dur":"4.6","text":"I can never represent a number with more digits than 5."},"1692.20":{"start":"1692.2","dur":"14.1","text":"Then you also allocate a specific number of bits so that it tends to be like"},"1706.30":{"start":"1706.3","dur":"6.51","text":"you can only go up to a certain number, like that&#39;s the largest exponent you can have,"},"1712.81":{"start":"1712.81","dur":"3.38","text":"and you can only go down to a certain exponent,"},"1716.19":{"start":"1716.19","dur":"2.58","text":"like that&#39;s the smallest exponent you can have."},"1718.77":{"start":"1718.77","dur":"5.64","text":"I don&#39;t remember the exact way bits are assigned to all of these values,"},"1724.41":{"start":"1724.41","dur":"3.53","text":"but a certain number of bits are dedicated to 1.2345,"},"1727.94":{"start":"1727.94","dur":"2.99","text":"another certain number of bits are dedicated to the exponent,"},"1730.93":{"start":"1730.93","dur":"4.74","text":"and it&#39;s only possible to represent an exponent of a certain size."},"1735.67":{"start":"1735.67","dur":"5.43","text":"[student] And a double? Is that like an extra long float? &gt;&gt;Yeah."},"1741.10":{"start":"1741.1","dur":"6.84","text":"It&#39;s the same thing as a float except now you&#39;re using 8 bytes instead of 4 bytes."},"1747.94":{"start":"1747.94","dur":"4.02","text":"Now you&#39;ll be able to use 9 digits or 10 digits,"},"1751.96":{"start":"1751.96","dur":"4.67","text":"and this will be able to go up to 300 instead of 100. &gt;&gt;[student] Okay."},"1756.63":{"start":"1756.63","dur":"4.92","text":"And floats are also 4 bytes. &gt;&gt;Yes."},"1761.55":{"start":"1761.55","dur":"5.97","text":"Well, again, it probably depends overall on general implementation,"},"1767.52":{"start":"1767.52","dur":"3.09","text":"but floats are 4 bytes, doubles are 8."},"1770.61":{"start":"1770.61","dur":"2.83","text":"Doubles are called double because they are double the size of floats."},"1773.44":{"start":"1773.44","dur":"4.94","text":"[student] Okay. And are there double doubles? &gt;&gt;There are not."},"1778.38":{"start":"1778.38","dur":"5.28","text":"I think-- &gt;&gt;[student] Like long longs? &gt;&gt;Yeah. I don&#39;t think so. Yes."},"1783.66":{"start":"1783.66","dur":"2.29","text":"[student] On last year&#39;s test there was a question about the main function"},"1785.95":{"start":"1785.95","dur":"3.54","text":"having to be part of your program."},"1789.49":{"start":"1789.49","dur":"2.82","text":"The answer was that it doesn&#39;t have to be part of your program."},"1792.31":{"start":"1792.31","dur":"2.79","text":"In what situation? That&#39;s what I saw."},"1795.10":{"start":"1795.1","dur":"3.99","text":"[Bowden] It seems-- &gt;&gt;[student] What situation?"},"1799.09":{"start":"1799.09","dur":"3.79","text":"Do you have the problem? &gt;&gt;[student] Yeah, I can definitely pull it up."},"1802.88":{"start":"1802.88","dur":"5.03","text":"It doesn&#39;t have to be, technically, but basically it&#39;s going to be."},"1807.91":{"start":"1807.91","dur":"2.12","text":"[student] I saw one on a different year&#39;s."},"1810.03":{"start":"1810.03","dur":"6.19","text":"It was like True or False: A valid-- &gt;&gt;Oh, a .c file?"},"1816.22":{"start":"1816.22","dur":"2.57","text":"[student] Any .c file must have-- [both speaking at once - unintelligible]"},"1818.79":{"start":"1818.79","dur":"2.33","text":"Okay. So that&#39;s separate."},"1821.12":{"start":"1821.12","dur":"5.68","text":"A .c file just needs to contain functions."},"1826.80":{"start":"1826.8","dur":"5.6","text":"You can compile a file into machine code, binary, whatever,"},"1832.40":{"start":"1832.4","dur":"4.22","text":"without it being executable yet."},"1836.62":{"start":"1836.62","dur":"2.8","text":"A valid executable must have a main function."},"1839.42":{"start":"1839.42","dur":"6.04","text":"You can write 100 functions in 1 file but no main"},"1845.46":{"start":"1845.46","dur":"3.34","text":"and then compile that down to binary,"},"1848.80":{"start":"1848.8","dur":"5.66","text":"then you write another file that only has main but it calls a bunch of these functions"},"1854.46":{"start":"1854.46","dur":"2.26","text":"in this binary file over here."},"1856.72":{"start":"1856.72","dur":"4.52","text":"And so when you&#39;re making the executable, that&#39;s what the linker does"},"1861.24":{"start":"1861.24","dur":"4.72","text":"is it combines these 2 binary files into an executable."},"1865.96":{"start":"1865.96","dur":"5.44","text":"So a .c file does not need to have a main function at all."},"1871.40":{"start":"1871.4","dur":"7.82","text":"And on big code bases you&#39;ll see thousands of .c files and 1 main file."},"1883.96":{"start":"1883.96","dur":"2.15","text":"More questions?"},"1889.31":{"start":"1889.31","dur":"2.63","text":"[student] There was another question."},"1891.94":{"start":"1891.94","dur":"4.77","text":"It said make is a compiler. True or False?"},"1896.71":{"start":"1896.71","dur":"5.32","text":"And the answer was false, and I understood why it&#39;s not like Clang."},"1902.03":{"start":"1902.03","dur":"2.74","text":"But what do we call make if it&#39;s not?"},"1904.77":{"start":"1904.77","dur":"5.22","text":"Make is basically just-- I can see exactly what it calls it."},"1909.99":{"start":"1909.99","dur":"2.42","text":"But it just runs commands."},"1913.65":{"start":"1913.65","dur":"2","text":"Make."},"1918.24":{"start":"1918.24","dur":"2.63","text":"I can pull this up. Yeah."},"1930.11":{"start":"1930.11","dur":"3.07","text":"Oh, yeah. Make also does that."},"1933.18":{"start":"1933.18","dur":"3.99","text":"This says the purpose of the make utility is to determine automatically"},"1937.17":{"start":"1937.17","dur":"2.44","text":"which pieces of a large program need to be recompiled"},"1939.61":{"start":"1939.61","dur":"2.74","text":"and issue the commands to recompile them."},"1942.35":{"start":"1942.35","dur":"5.34","text":"You can make make files that are absolutely huge."},"1947.69":{"start":"1947.69","dur":"5.52","text":"Make looks at the time stamps of files and, like we said before,"},"1953.21":{"start":"1953.21","dur":"3.72","text":"you can compile individual files down, and it&#39;s not until you get to the linker"},"1956.93":{"start":"1956.93","dur":"2.34","text":"that they&#39;re put together into an executable."},"1959.27":{"start":"1959.27","dur":"4.54","text":"So if you have 10 different files and you make a change to 1 of them,"},"1963.81":{"start":"1963.81","dur":"4.06","text":"then what make is going to do is just recompile that 1 file"},"1967.87":{"start":"1967.87","dur":"2.77","text":"and then relink everything together."},"1970.64":{"start":"1970.64","dur":"2.38","text":"But it&#39;s much dumber than that."},"1973.02":{"start":"1973.02","dur":"2.67","text":"It&#39;s up to you to completely define that that&#39;s what it should be doing."},"1975.69":{"start":"1975.69","dur":"3.87","text":"It by default has the ability to recognize this time stamp stuff,"},"1979.56":{"start":"1979.56","dur":"3.66","text":"but you can write a make file to do anything."},"1983.22":{"start":"1983.22","dur":"5.93","text":"You can write a make file so that when you type make it just cd&#39;s to another directory."},"1989.15":{"start":"1989.15","dur":"6.41","text":"I was getting frustrated because I tack everything inside of my Appliance"},"1995.56":{"start":"1995.56","dur":"6.18","text":"and then I view the PDF from the Mac."},"2001.74":{"start":"2001.74","dur":"8.98","text":"So I go to Finder and I can do Go, Connect to Server,"},"2010.72":{"start":"2010.72","dur":"6.23","text":"and the server I connect to is my Appliance, and then I open up the PDF"},"2016.95":{"start":"2016.95","dur":"3.24","text":"that gets compiled by LaTeX."},"2020.19":{"start":"2020.19","dur":"9.13","text":"But I was getting frustrated because every single time I needed to refresh the PDF,"},"2029.32":{"start":"2029.32","dur":"4.58","text":"I had to copy it to a specific directory that it could access"},"2033.90":{"start":"2033.9","dur":"3.81","text":"and it was getting annoying."},"2037.71":{"start":"2037.71","dur":"4.94","text":"So instead I wrote a make file, which you have to define how it makes things."},"2042.65":{"start":"2042.65","dur":"3.48","text":"How you make in this is PDF LaTeX."},"2046.13":{"start":"2046.13","dur":"3.96","text":"Just like any other make file--or I guess you haven&#39;t seen the make files,"},"2050.09":{"start":"2050.09","dur":"3.42","text":"but we have in the Appliance a global make file that just says,"},"2053.51":{"start":"2053.51","dur":"3.169","text":"if you are compiling a C file, use Clang."},"2056.68":{"start":"2056.679","dur":"4.281","text":"And so here in my make file that I make I say,"},"2060.96":{"start":"2060.96","dur":"4.06","text":"this file you&#39;re going to want to compile with PDF LaTeX."},"2065.02":{"start":"2065.02","dur":"2.869","text":"And so it&#39;s PDF LaTeX that&#39;s doing the compiling."},"2067.89":{"start":"2067.889","dur":"3.991","text":"Make is not compiling. It&#39;s just running these commands in the sequence I specified."},"2071.88":{"start":"2071.88","dur":"4.23","text":"So it runs PDF LaTeX, it copies it to the directory I want it to be copied to,"},"2076.11":{"start":"2076.11","dur":"2.16","text":"it cd&#39;s to the directory and does other things,"},"2078.27":{"start":"2078.27","dur":"4.11","text":"but all it does is recognize when a file changes,"},"2082.38":{"start":"2082.38","dur":"3.109","text":"and if it changes, then it will run the commands that it&#39;s supposed to run"},"2085.49":{"start":"2085.489","dur":"3.271","text":"when the file changes. &gt;&gt;[student] Okay."},"2090.51":{"start":"2090.51","dur":"3.91","text":"I don&#39;t know where the global make files are for me to check it out."},"2097.21":{"start":"2097.21","dur":"7.08","text":"Other questions? Anything from past quizzes? Any pointer things?"},"2106.20":{"start":"2106.2","dur":"2.53","text":"There are subtle things with pointers like--"},"2108.73":{"start":"2108.73","dur":"1.49","text":"I&#39;m not going to be able to find a quiz question on it--"},"2110.22":{"start":"2110.22","dur":"6.03","text":"but just like this sort of thing."},"2119.68":{"start":"2119.68","dur":"4.38","text":"Make sure you understand that when I say int *x *y--"},"2124.89":{"start":"2124.89","dur":"3.24","text":"This isn&#39;t exactly anything here, I guess."},"2128.13":{"start":"2128.13","dur":"4.01","text":"But like *x *y, those are 2 variables that are on the stack."},"2132.14":{"start":"2132.14","dur":"5.08","text":"When I say x = malloc(sizeof(int)), x is still a variable on the stack,"},"2137.22":{"start":"2137.22","dur":"3.96","text":"malloc is some block over in the heap, and we&#39;re having x point to the heap."},"2141.18":{"start":"2141.18","dur":"2.72","text":"So something on the stack points to the heap."},"2143.90":{"start":"2143.9","dur":"4.2","text":"Whenever you malloc anything, you&#39;re inevitably storing it inside of a pointer."},"2148.10":{"start":"2148.1","dur":"7.84","text":"So that pointer is on the stack, the malloced block is on the heap."},"2155.94":{"start":"2155.94","dur":"5.3","text":"A lot of people get confused and say int *x = malloc; x is on the heap."},"2161.24":{"start":"2161.24","dur":"2.86","text":"No. What x points to is on the heap."},"2164.10":{"start":"2164.1","dur":"4.44","text":"x itself is on the stack, unless for whatever reason you have x be a global variable,"},"2168.54":{"start":"2168.54","dur":"3.42","text":"in which case it happens to be in another region of memory."},"2173.45":{"start":"2173.45","dur":"7.37","text":"So keeping track, these box and arrow diagrams are pretty common for the quiz."},"2180.82":{"start":"2180.82","dur":"4.92","text":"Or if it&#39;s not on quiz 0, it will be on quiz 1."},"2187.57":{"start":"2187.57","dur":"4.37","text":"You should know all of these, the steps in compiling"},"2191.94":{"start":"2191.94","dur":"3.8","text":"since you had to answer questions on those. Yes."},"2195.74":{"start":"2195.74","dur":"3.2","text":"[student] Could we go over those steps-- &gt;&gt;Sure."},"2208.34":{"start":"2208.34","dur":"10.3","text":"Before steps and compiling we have preprocessing,"},"2218.64":{"start":"2218.64","dur":"18.11","text":"compiling, assembling, and linking."},"2236.75":{"start":"2236.75","dur":"4.73","text":"Preprocessing. What does that do?"},"2249.72":{"start":"2249.72","dur":"2.57","text":"It is the easiest step in--well, not like--"},"2252.29":{"start":"2252.29","dur":"3.48","text":"that doesn&#39;t mean it should be obvious, but it&#39;s the easiest step."},"2255.77":{"start":"2255.77","dur":"2.64","text":"You guys could implement it yourselves. Yeah."},"2258.41":{"start":"2258.41","dur":"5","text":"[student] Take what you have in your includes like this and it copies and then also defines."},"2263.41":{"start":"2263.41","dur":"5.84","text":"It looks for things like #include and #define,"},"2269.25":{"start":"2269.25","dur":"4.55","text":"and it just copies and pastes what those actually mean."},"2273.80":{"start":"2273.8","dur":"5.44","text":"So when you say #include cs50.h, the preprocessor is copying and pasting cs50.h"},"2279.24":{"start":"2279.24","dur":"1.79","text":"into that line."},"2281.03":{"start":"2281.03","dur":"5.61","text":"When you say #define x to be 4, the preprocessor goes through the entire program"},"2286.64":{"start":"2286.64","dur":"3.76","text":"and replaces all instances of x with 4."},"2290.40":{"start":"2290.4","dur":"7.13","text":"So the preprocessor takes a valid C file and outputs a valid C file"},"2297.53":{"start":"2297.53","dur":"2.77","text":"where things have been copied and pasted."},"2300.30":{"start":"2300.3","dur":"3.93","text":"So now compiling. What does that do?"},"2305.94":{"start":"2305.94","dur":"2.27","text":"[student] It goes from C to binary."},"2308.21":{"start":"2308.21","dur":"2.76","text":"[Bowden] It doesn&#39;t go all the way to binary."},"2310.97":{"start":"2310.97","dur":"3.25","text":"[student] To machine code then? &gt;&gt;It&#39;s not machine code."},"2314.22":{"start":"2314.22","dur":"1.48","text":"[student] Assembly? &gt;&gt;Assembly."},"2315.70":{"start":"2315.7","dur":"3.19","text":"It goes to Assembly before it goes all the way to C code,"},"2318.89":{"start":"2318.89","dur":"6.12","text":"and most languages do something like this."},"2327.74":{"start":"2327.74","dur":"2.85","text":"Pick any high-level language, and if you&#39;re going to compile it,"},"2330.59":{"start":"2330.59","dur":"1.8","text":"it&#39;s likely to compile in steps."},"2332.39":{"start":"2332.39","dur":"5.75","text":"First it&#39;s going to compile Python to C, then it&#39;s going to compile C to Assembly,"},"2338.14":{"start":"2338.14","dur":"3.46","text":"and then Assembly is going to get translated to binary."},"2341.60":{"start":"2341.6","dur":"6.2","text":"So compiling is going to bring it from C to Assembly."},"2347.80":{"start":"2347.8","dur":"4.33","text":"The word compiling usually means bringing it from a higher level"},"2352.13":{"start":"2352.13","dur":"2.21","text":"to a lower level programming language."},"2354.34":{"start":"2354.34","dur":"4.85","text":"So this is the only step in compilation where you start with a high-level language"},"2359.19":{"start":"2359.19","dur":"4.08","text":"and end up in a low-level language, and that&#39;s why the step is called compiling."},"2365.28":{"start":"2365.28","dur":"8.09","text":"[student] During compiling, let&#39;s say that you&#39;ve done #include cs50.h."},"2373.37":{"start":"2373.37","dur":"8.82","text":"Will the compiler recompile the cs50.h, like the functions that are in there,"},"2382.19":{"start":"2382.19","dur":"3.09","text":"and translate that into Assembly code as well,"},"2385.28":{"start":"2385.28","dur":"5.55","text":"or will it copy and paste something that&#39;s been pre-Assembly?"},"2390.83":{"start":"2390.83","dur":"6.08","text":"cs50.h will pretty much never end up in Assembly."},"2399.74":{"start":"2399.74","dur":"3.94","text":"Stuff like function prototypes and things are just for you to be careful."},"2403.68":{"start":"2403.68","dur":"5.59","text":"It guarantees that the compiler can check things like you&#39;re calling functions"},"2409.27":{"start":"2409.27","dur":"3.64","text":"with the right return types and the right arguments and stuff."},"2412.91":{"start":"2412.91","dur":"5.44","text":"So cs50.h will be preprocessed into the file, and then when it&#39;s compiling"},"2418.35":{"start":"2418.35","dur":"3.96","text":"it&#39;s basically thrown away after it makes sure that everything is being called correctly."},"2422.31":{"start":"2422.31","dur":"7.1","text":"But the functions defined in the CS50 library, which are separate from cs50.h,"},"2429.41":{"start":"2429.41","dur":"4.2","text":"those will not be separately compiled."},"2433.61":{"start":"2433.61","dur":"3.66","text":"That will actually come down in the linking step, so we&#39;ll get to that in a second."},"2437.27":{"start":"2437.27","dur":"2.83","text":"But first, what is assembling?"},"2441.85":{"start":"2441.85","dur":"2.65","text":"[student] Assembly to binary? &gt;&gt;Yeah."},"2446.30":{"start":"2446.3","dur":"1.89","text":"Assembling."},"2448.19":{"start":"2448.19","dur":"6.52","text":"We don&#39;t call it compiling because Assembly is pretty much a pure translation of binary."},"2454.71":{"start":"2454.71","dur":"5.52","text":"There is very little logic in going from Assembly to binary."},"2460.23":{"start":"2460.23","dur":"2.95","text":"It&#39;s just like looking up in a table, oh, we have this instruction;"},"2463.18":{"start":"2463.18","dur":"3.11","text":"that corresponds to binary 01110."},"2470.20":{"start":"2470.2","dur":"5.03","text":"And so the files that assembling generally outputs are .o files."},"2475.23":{"start":"2475.23","dur":"3.79","text":"And .o files are what we were saying before,"},"2479.02":{"start":"2479.02","dur":"2.55","text":"how a file does not need to have a main function."},"2481.57":{"start":"2481.57","dur":"6.07","text":"Any file can be compiled down to a .o file as long as it&#39;s a valid C file."},"2487.64":{"start":"2487.64","dur":"2.66","text":"It can be compiled down to .o."},"2490.30":{"start":"2490.3","dur":"12.73","text":"Now, linking is what actually brings a bunch of .o files and brings them to an executable."},"2503.03":{"start":"2503.03","dur":"8.08","text":"And so what linking does is you can think of the CS50 library as a .o file."},"2511.11":{"start":"2511.11","dur":"5.87","text":"It is an already compiled binary file."},"2516.98":{"start":"2516.98","dur":"6.55","text":"And so when you compile your file, your hello.c, which calls GetString,"},"2523.53":{"start":"2523.53","dur":"2.83","text":"hello.c gets compiled down to hello.o,"},"2526.36":{"start":"2526.36","dur":"2.55","text":"hello.o is now in binary."},"2528.91":{"start":"2528.91","dur":"3.92","text":"It uses GetString, so it needs to go over to cs50.o,"},"2532.83":{"start":"2532.83","dur":"3.56","text":"and the linker smooshes them together and copies GetString into this file"},"2536.39":{"start":"2536.39","dur":"4.25","text":"and comes out with an executable that has all functions it needs."},"2540.64":{"start":"2540.64","dur":"11.98","text":"So cs50.o isn&#39;t actually an O file, but it&#39;s close enough that there is no fundamental difference."},"2552.62":{"start":"2552.62","dur":"4.26","text":"So linking just brings a bunch of files together"},"2556.88":{"start":"2556.88","dur":"4.51","text":"that separately contain all of the functions I need to use"},"2561.39":{"start":"2561.39","dur":"4.73","text":"and creates the executable that will actually run."},"2568.42":{"start":"2568.42","dur":"2.36","text":"And so that&#39;s also what we were saying before"},"2570.78":{"start":"2570.78","dur":"5.19","text":"where you can have 1000 .c files, you compile them all to .o files,"},"2575.97":{"start":"2575.97","dur":"4.07","text":"which will probably take a while, then you change 1 .c file."},"2580.04":{"start":"2580.04","dur":"5.44","text":"You only need to recompile that 1 .c file and then relink everything else,"},"2585.48":{"start":"2585.48","dur":"2.21","text":"link everything back together."},"2589.58":{"start":"2589.58","dur":"1.85","text":"[student] When we&#39;re linking we write lcs50?"},"2591.43":{"start":"2591.43","dur":"9.08","text":"Yeah, so -lcs50. That flag signals to the linker that you should be linking in that library."},"2606.68":{"start":"2606.68","dur":"2.23","text":"Questions?"},"2621.31":{"start":"2621.31","dur":"5.55","text":"Have we gone over binary other than that 5 seconds in the first lecture?"},"2630.13":{"start":"2630.13","dur":"2.88","text":"I don&#39;t think so."},"2635.53":{"start":"2635.53","dur":"3.29","text":"You should know all of the big Os that we&#39;ve gone over,"},"2638.82":{"start":"2638.82","dur":"3.85","text":"and you should be able to, if we gave you a function,"},"2642.67":{"start":"2642.67","dur":"6.74","text":"you should be able to say it&#39;s big O, roughly. Or well, big O is rough."},"2649.41":{"start":"2649.41","dur":"5.89","text":"So if you see nested for loops looping over the same number of things,"},"2655.30":{"start":"2655.3","dur":"6.96","text":"like int i, i &lt; n; int j, j &lt; n-- &gt;&gt;[student] n squared. &gt;&gt;it tends to be n squared."},"2662.26":{"start":"2662.26","dur":"3.02","text":"If you have triple nested, it tends to be n cubed."},"2665.28":{"start":"2665.28","dur":"4.05","text":"So that sort of thing you should be able to point out immediately."},"2669.33":{"start":"2669.33","dur":"4.56","text":"You need to know insertion sort and bubble sort and merge sort and all of those."},"2673.89":{"start":"2673.89","dur":"7.53","text":"It&#39;s easier to understand why they are those n squared and n log n and all of that"},"2681.42":{"start":"2681.42","dur":"6.39","text":"because I think there was on a quiz one year where we basically gave you"},"2687.81":{"start":"2687.81","dur":"7.24","text":"an implementation of bubble sort and said, &quot;What is the running time of this function?&quot;"},"2695.05":{"start":"2695.05","dur":"5.97","text":"So if you recognize it as bubble sort, then you can immediately say n squared."},"2701.02":{"start":"2701.02","dur":"4.45","text":"But if you just look at it, you don&#39;t even need to realize it&#39;s bubble sort;"},"2705.47":{"start":"2705.47","dur":"3.52","text":"you can just say this is doing this and this. This is n squared."},"2712.35":{"start":"2712.35","dur":"2.36","text":"[student] Are there any tough examples you can come up with,"},"2714.71":{"start":"2714.71","dur":"5.66","text":"like a similar idea of figuring out?"},"2720.37":{"start":"2720.37","dur":"4.08","text":"I don&#39;t think we would give you any tough examples."},"2724.45":{"start":"2724.45","dur":"5.73","text":"The bubble sort thing is about as tough as we would go,"},"2730.18":{"start":"2730.18","dur":"6.1","text":"and even that, as long as you understand that you&#39;re iterating over the array"},"2736.28":{"start":"2736.28","dur":"5.39","text":"for each element in the array, which is going to be something that&#39;s n squared."},"2745.37":{"start":"2745.37","dur":"4.57","text":"There are general questions, like right here we have-- Oh."},"2755.29":{"start":"2755.29","dur":"3.24","text":"Just the other day, Doug claimed, &quot;I have invented an algorithm that can sort an array"},"2758.53":{"start":"2758.53","dur":"3.25","text":"&quot;of n numbers in O(log n) time!&quot;"},"2761.78":{"start":"2761.78","dur":"3.12","text":"So how do we know that&#39;s impossible?"},"2764.90":{"start":"2764.9","dur":"3.95","text":"[inaudible student response] &gt;&gt;Yeah."},"2768.85":{"start":"2768.85","dur":"4.86","text":"At the very least, you have to touch each element in the array,"},"2773.71":{"start":"2773.71","dur":"2.5","text":"so it&#39;s impossible to sort an array of--"},"2776.21":{"start":"2776.21","dur":"4.64","text":"If everything is in unsorted order, then you&#39;re going to be touching everything in the array,"},"2780.85":{"start":"2780.85","dur":"4.47","text":"so it&#39;s impossible to do it in less than O of n."},"2787.43":{"start":"2787.43","dur":"2.91","text":"[student] You showed us that example of being able to do it in O of n"},"2790.34":{"start":"2790.34","dur":"3.58","text":"if you use a lot of memory. &gt;&gt;Yeah."},"2793.92":{"start":"2793.92","dur":"4.05","text":"And that&#39;s-- I forget what that&#39;s-- Is it counting sort?"},"2807.36":{"start":"2807.36","dur":"3.97","text":"Hmm. That is an integer sorting algorithm."},"2819.85":{"start":"2819.85","dur":"5.25","text":"I was looking for the special name for this that I couldn&#39;t remember last week."},"2825.10":{"start":"2825.1","dur":"7.9","text":"Yeah. These are the types of sorts that can accomplish things in big O of n."},"2833.00":{"start":"2833","dur":"5.43","text":"But there are limitations, like you can only use integers up to a certain number."},"2840.87":{"start":"2840.87","dur":"3.69","text":"Plus if you&#39;re trying to sort something that&#39;s--"},"2844.56":{"start":"2844.56","dur":"6.19","text":"If your array is 012, -12, 151, 4 million,"},"2850.75":{"start":"2850.75","dur":"4.37","text":"then that single element is going to completely ruin the entire sorting."},"2862.06":{"start":"2862.06","dur":"1.97","text":"Questions?"},"2869.48":{"start":"2869.48","dur":"9.39","text":"[student] If you have a recursive function and it just makes the recursive calls"},"2878.87":{"start":"2878.87","dur":"3.36","text":"within a return statement, that&#39;s tail recursive,"},"2882.23":{"start":"2882.23","dur":"5.13","text":"and so would that not use more memory during runtime"},"2887.36":{"start":"2887.36","dur":"5.19","text":"or it would at least use comparable memory as an iterative solution?"},"2892.55":{"start":"2892.55","dur":"1.98","text":"[Bowden] Yes."},"2894.53":{"start":"2894.53","dur":"5.31","text":"It would likely be somewhat slower, but not really."},"2899.84":{"start":"2899.84","dur":"3.45","text":"Tail recursive is pretty good."},"2903.29":{"start":"2903.29","dur":"9.35","text":"Looking again at stack frames, let&#39;s say we have main"},"2912.64":{"start":"2912.64","dur":"10.28","text":"and we have int bar(int x) or something."},"2922.92":{"start":"2922.92","dur":"9.39","text":"This isn&#39;t a perfect recursive function, but return bar(x - 1)."},"2932.31":{"start":"2932.31","dur":"5.31","text":"So obviously, this is flawed. You need base cases and stuff."},"2937.62":{"start":"2937.62","dur":"2.74","text":"But the idea here is that this is tail recursive,"},"2940.36":{"start":"2940.36","dur":"5.66","text":"which means when main calls bar it&#39;s going to get its stack frame."},"2949.55":{"start":"2949.55","dur":"2.89","text":"In this stack frame there&#39;s going to be a little block of memory"},"2952.44":{"start":"2952.44","dur":"5.05","text":"that corresponds to its argument x."},"2957.49":{"start":"2957.49","dur":"8.35","text":"And so let&#39;s say main happens to call bar(100);"},"2965.84":{"start":"2965.84","dur":"4.21","text":"So x is going to start out as 100."},"2970.05":{"start":"2970.05","dur":"5.61","text":"If the compiler recognizes that this is a tail recursive function,"},"2975.66":{"start":"2975.66","dur":"2.88","text":"then when bar makes its recursive call to bar,"},"2978.54":{"start":"2978.54","dur":"6.95","text":"instead of making a new stack frame, which is where the stack starts growing largely,"},"2985.49":{"start":"2985.49","dur":"2.73","text":"eventually it will run into the heap and then you get segfaults"},"2988.22":{"start":"2988.22","dur":"3.37","text":"because memory starts colliding."},"2991.59":{"start":"2991.59","dur":"3.24","text":"So instead of making its own stack frame, it can realize,"},"2994.83":{"start":"2994.83","dur":"4.25","text":"hey, I never really need to come back to this stack frame,"},"2999.08":{"start":"2999.08","dur":"8.96","text":"so instead I&#39;ll just replace this argument with 99 and then start bar all over."},"3008.04":{"start":"3008.04","dur":"3.77","text":"And then it will do it again and it will reach return bar(x - 1),"},"3011.81":{"start":"3011.81","dur":"5.51","text":"and instead of making a new stack frame, it will just replace its current argument with 98"},"3017.32":{"start":"3017.32","dur":"3.42","text":"and then jump back to the very beginning of bar."},"3023.86":{"start":"3023.86","dur":"6.57","text":"Those operations, replacing that 1 value on the stack and jumping back to the beginning,"},"3030.43":{"start":"3030.43","dur":"2","text":"are pretty efficient."},"3032.43":{"start":"3032.43","dur":"9.07","text":"So not only is this the same memory usage as a separate function which is iterative"},"3041.50":{"start":"3041.5","dur":"3.89","text":"because you&#39;re only using 1 stack frame, but you&#39;re not suffering the downsides"},"3045.39":{"start":"3045.39","dur":"1.85","text":"of having to call functions."},"3047.24":{"start":"3047.24","dur":"3","text":"Calling functions can be somewhat expensive because it has to do all this setup"},"3050.24":{"start":"3050.24","dur":"2.23","text":"and teardown and all this stuff."},"3052.47":{"start":"3052.47","dur":"5.69","text":"So this tail recursion is good."},"3058.16":{"start":"3058.16","dur":"3.01","text":"[student] Why does it not create new steps?"},"3061.17":{"start":"3061.17","dur":"1.81","text":"Because it realizes it doesn&#39;t need to."},"3062.98":{"start":"3062.98","dur":"4.82","text":"The call to bar is just returning the recursive call."},"3067.80":{"start":"3067.8","dur":"4.42","text":"So it doesn&#39;t need to do anything with the return value."},"3072.22":{"start":"3072.22","dur":"2.9","text":"It&#39;s just going to immediately return it."},"3075.12":{"start":"3075.12","dur":"5.41","text":"So it&#39;s just going to replace its own argument and start over."},"3080.53":{"start":"3080.53","dur":"5.25","text":"And also, if you don&#39;t have the tail recursive version,"},"3085.78":{"start":"3085.78","dur":"5.68","text":"then you get all these bars where when this bar returns"},"3091.46":{"start":"3091.46","dur":"4.55","text":"it has to return its value to this one, then that bar immediately returns"},"3096.01":{"start":"3096.01","dur":"3.61","text":"and it returns its value to this one, then it&#39;s just going to immediately return"},"3099.62":{"start":"3099.62","dur":"1.73","text":"and return its value to this one."},"3101.35":{"start":"3101.35","dur":"4","text":"So you&#39;re saving this popping all of these things off of the stack"},"3105.35":{"start":"3105.35","dur":"3.38","text":"since the return value is just going to be passed all the way back up anyway."},"3108.73":{"start":"3108.73","dur":"6.67","text":"So why not just replace our argument with the updated argument and start over?"},"3117.46":{"start":"3117.46","dur":"3.69","text":"If the function is not tail recursive, if you do something like--"},"3121.15":{"start":"3121.15","dur":"6.38","text":"[student] if bar(x + 1). &gt;&gt;Yeah."},"3127.53":{"start":"3127.53","dur":"4.24","text":"So if you put it in condition, then you&#39;re doing something with the return value."},"3131.77":{"start":"3131.77","dur":"4.49","text":"Or even if you just do return 2 * bar(x - 1)."},"3136.26":{"start":"3136.26","dur":"7.3","text":"So now bar(x - 1) needs to return in order for it to calculate 2 times that value,"},"3143.56":{"start":"3143.56","dur":"2.58","text":"so now it does need its own separate stack frame,"},"3146.14":{"start":"3146.14","dur":"5.04","text":"and now, no matter how hard you try, you&#39;re going to need to--"},"3151.18":{"start":"3151.18","dur":"3.23","text":"This isn&#39;t tail recursive."},"3154.41":{"start":"3154.41","dur":"3.18","text":"[student] Would I try to bring a recursion to aim for a tail recursion--"},"3157.59":{"start":"3157.59","dur":"3.86","text":"[Bowden] In an ideal world, but in CS50 you don&#39;t have to."},"3163.78":{"start":"3163.78","dur":"5.5","text":"In order to get tail recursion, generally, you set up an additional argument"},"3169.28":{"start":"3169.28","dur":"4.27","text":"where bar will take int x into y"},"3173.55":{"start":"3173.55","dur":"3.44","text":"and y corresponds to the ultimate thing you want to return."},"3176.99":{"start":"3176.99","dur":"6.66","text":"So then this you&#39;re going to be returning bar(x - 1), 2 * y."},"3183.65":{"start":"3183.65","dur":"6.16","text":"So that&#39;s just a high-level how you transform things to be tail recursive."},"3189.81":{"start":"3189.81","dur":"3.98","text":"But the extra argument--"},"3193.79":{"start":"3193.79","dur":"3.62","text":"And then in the end when you reach your base case, you just return y"},"3197.41":{"start":"3197.41","dur":"5.33","text":"because you&#39;ve been accumulating the entire time the return value that you want."},"3202.74":{"start":"3202.74","dur":"4.54","text":"You kind of have been doing it iteratively but using recursive calls."},"3212.51":{"start":"3212.51","dur":"2.39","text":"Questions?"},"3214.90":{"start":"3214.9","dur":"4.99","text":"[student] Maybe about pointer arithmetic, like when using strings. &gt;&gt;Sure."},"3219.89":{"start":"3219.89","dur":"3.72","text":"Pointer arithmetic."},"3223.61":{"start":"3223.61","dur":"4.83","text":"When using strings it&#39;s easy because strings are char stars,"},"3228.44":{"start":"3228.44","dur":"3.42","text":"chars are forever and always a single byte,"},"3231.86":{"start":"3231.86","dur":"5.68","text":"and so pointer arithmetic is equivalent to regular arithmetic when you&#39;re dealing with strings."},"3237.54":{"start":"3237.54","dur":"11.25","text":"Let&#39;s just say char* s = &quot;hello&quot;."},"3248.79":{"start":"3248.79","dur":"2.64","text":"So we have a block in memory."},"3259.49":{"start":"3259.49","dur":"2.89","text":"It needs 6 bytes because you always need the null terminator."},"3262.38":{"start":"3262.38","dur":"6.24","text":"And char* s is going to point to the beginning of this array."},"3268.62":{"start":"3268.62","dur":"4.21","text":"So s points there."},"3272.83":{"start":"3272.83","dur":"3.88","text":"Now, this is basically how any array works,"},"3276.71":{"start":"3276.71","dur":"4.07","text":"regardless of whether it was a return by malloc or whether it&#39;s on the stack."},"3280.78":{"start":"3280.78","dur":"6.33","text":"Any array is basically a pointer to the start of the array,"},"3287.11":{"start":"3287.11","dur":"6.53","text":"and then any array operation, any indexing, is just going into that array a certain offset."},"3293.64":{"start":"3293.64","dur":"11.72","text":"So when I say something like s[3]; this is going to s and counting 3 chars in."},"3305.36":{"start":"3305.36","dur":"7.13","text":"So s[3], we have 0, 1, 2, 3, so s[3] is going to refer to this l."},"3312.49":{"start":"3312.49","dur":"7.97","text":"[student] And we could reach the same value by doing s + 3 and then parentheses star?"},"3320.46":{"start":"3320.46","dur":"2.11","text":"Yes."},"3322.57":{"start":"3322.57","dur":"3.44","text":"This is equivalent to *(s + 3);"},"3326.01":{"start":"3326.01","dur":"5.23","text":"and that is forever and always equivalent no matter what you do."},"3331.24":{"start":"3331.24","dur":"2.83","text":"You never need to use the bracket syntax."},"3334.07":{"start":"3334.07","dur":"3.7","text":"You can always use the *(s + 3) syntax."},"3337.77":{"start":"3337.77","dur":"2.41","text":"People tend to like the bracket syntax, though."},"3340.18":{"start":"3340.18","dur":"3.68","text":"[student] So all arrays are actually just pointers."},"3343.86":{"start":"3343.86","dur":"9.77","text":"There is a slight distinction when I say int x[4]; &gt;&gt;[student] Does that create the memory?"},"3353.63":{"start":"3353.63","dur":"9.69","text":"[Bowden] That is going to create 4 ints on the stack, so 16 bytes overall."},"3363.32":{"start":"3363.32","dur":"2.38","text":"It&#39;s going to create 16 bytes on the stack."},"3365.70":{"start":"3365.7","dur":"3.49","text":"x isn&#39;t stored anywhere."},"3369.19":{"start":"3369.19","dur":"4.23","text":"It is just a symbol referring to the start of the thing."},"3373.42":{"start":"3373.42","dur":"4.26","text":"Because you declared the array inside of this function,"},"3377.68":{"start":"3377.68","dur":"4.66","text":"what the compiler is going to do is just replace all instances of the variable x"},"3382.34":{"start":"3382.34","dur":"4.06","text":"with where it happened to choose to put these 16 bytes."},"3386.40":{"start":"3386.4","dur":"3.64","text":"It can&#39;t do that with char* s because s is an actual pointer."},"3390.04":{"start":"3390.04","dur":"2.34","text":"It is free to then point to other things."},"3392.38":{"start":"3392.38","dur":"3.76","text":"x is a constant. You can&#39;t have it point to a different array. &gt;&gt;[student] Okay."},"3396.14":{"start":"3396.14","dur":"7.28","text":"But this idea, this indexing, is the same regardless of whether it&#39;s a traditional array"},"3403.42":{"start":"3403.42","dur":"4.81","text":"or if it&#39;s a pointer to something or if it&#39;s a pointer to a malloced array."},"3408.23":{"start":"3408.23","dur":"11.54","text":"And in fact, it is so equivalent that that is also the same thing."},"3419.77":{"start":"3419.77","dur":"5.67","text":"It actually just translates what&#39;s inside of the brackets and what&#39;s left of the brackets,"},"3425.44":{"start":"3425.44","dur":"2.53","text":"adds them together, and dereferences."},"3427.97":{"start":"3427.97","dur":"6.74","text":"So this is just as valid as *(s + 3) or s[3]."},"3436.21":{"start":"3436.21","dur":"5.88","text":"[student] Can you have pointers pointing to 2-dimensional arrays?"},"3442.09":{"start":"3442.09","dur":"5.29","text":"It&#39;s harder. Traditionally, no."},"3447.38":{"start":"3447.38","dur":"7.34","text":"A 2-dimensional array is just a 1-dimensional array with some convenient syntax"},"3454.72":{"start":"3454.72","dur":"19.39","text":"because when I say int x[3][3], this is really just 1 array with 9 values."},"3475.50":{"start":"3475.5","dur":"7.5","text":"And so when I index, the compiler knows what I mean."},"3483.00":{"start":"3483","dur":"10.09","text":"If I say x[1][2], it knows I want to go to the second row, so it&#39;s going to skip the first 3,"},"3493.09":{"start":"3493.09","dur":"4.37","text":"and then it wants the second thing in that, so it&#39;s going to get this one."},"3497.46":{"start":"3497.46","dur":"3.02","text":"But it is still just a single-dimensional array."},"3500.48":{"start":"3500.48","dur":"3.18","text":"And so if I wanted to assign a pointer to that array,"},"3503.66":{"start":"3503.66","dur":"6.11","text":"I would say int *p = x;"},"3509.77":{"start":"3509.77","dur":"3.45","text":"The type of x is just--"},"3513.22":{"start":"3513.22","dur":"5.06","text":"It&#39;s rough saying type of x since it is just a symbol and it&#39;s not an actual variable,"},"3518.28":{"start":"3518.28","dur":"1.86","text":"but it is just an int *."},"3520.14":{"start":"3520.14","dur":"4.7","text":"x is just a pointer to the start of this. &gt;&gt;[student] Okay."},"3524.84":{"start":"3524.84","dur":"7.72","text":"And so I won&#39;t be able to access [1][2]."},"3532.56":{"start":"3532.56","dur":"5.81","text":"I think there is special syntax for declaring a pointer,"},"3538.37":{"start":"3538.37","dur":"14.11","text":"something ridiculous like int (*p[--something absolutely ridiculous. I don&#39;t even know."},"3552.48":{"start":"3552.48","dur":"4.61","text":"But there is a syntax for declaring pointers like with parentheses and things."},"3557.09":{"start":"3557.09","dur":"5.87","text":"It may not even let you do that."},"3562.96":{"start":"3562.96","dur":"3.68","text":"I could look back at something that would tell me the truth."},"3566.64":{"start":"3566.64","dur":"7.52","text":"I will look for it later, if there is a syntax for point. But you will never see it."},"3574.16":{"start":"3574.16","dur":"5.51","text":"And even the syntax is so archaic that if you use it, people will be baffled."},"3579.67":{"start":"3579.67","dur":"3.87","text":"Multidimensional arrays are pretty rare as it is."},"3583.54":{"start":"3583.54","dur":"1.09","text":"You pretty much--"},"3584.63":{"start":"3584.63","dur":"3.86","text":"Well, if you&#39;re doing matrix things it&#39;s not going to be rare,"},"3588.49":{"start":"3588.49","dur":"8.24","text":"but in C you&#39;re rarely going to be using multidimensional arrays."},"3597.63":{"start":"3597.63","dur":"2.84","text":"Yeah. &gt;&gt;[student] Let&#39;s say you have a really long array."},"3600.47":{"start":"3600.47","dur":"3.43","text":"So in virtual memory it would appear to be all consecutive,"},"3603.90":{"start":"3603.9","dur":"1.74","text":"like the elements right next to each other,"},"3605.64":{"start":"3605.64","dur":"3.13","text":"but in the physical memory, would it be possible for that to be split up? &gt;&gt;Yes."},"3608.77":{"start":"3608.77","dur":"8.09","text":"How virtual memory works is it just separates--"},"3619.22":{"start":"3619.22","dur":"5.64","text":"The unit of allocation is a page, which tends to be 4 kilobytes,"},"3624.86":{"start":"3624.86","dur":"4.82","text":"and so when a process says, hey, I want to use this memory,"},"3629.68":{"start":"3629.68","dur":"6.29","text":"the operating system is going to allocate it 4 kilobytes for that little block of memory."},"3635.97":{"start":"3635.97","dur":"3.13","text":"Even if you only use a single little byte in the entire block of memory,"},"3639.10":{"start":"3639.1","dur":"3.75","text":"the operating system is going to give it the full 4 kilobytes."},"3642.85":{"start":"3642.85","dur":"6.56","text":"So what this means is I could have--let&#39;s say this is my stack."},"3649.41":{"start":"3649.41","dur":"3.77","text":"This stack could be separated. My stack could be megabytes and megabytes."},"3653.18":{"start":"3653.18","dur":"1.84","text":"My stack could be huge."},"3655.02":{"start":"3655.02","dur":"5.2","text":"But the stack itself has to be split into individual pages,"},"3660.22":{"start":"3660.22","dur":"8.79","text":"which if we look at over here let&#39;s say this is our RAM,"},"3669.01":{"start":"3669.01","dur":"7.59","text":"if I have 2 gigabytes of RAM, this is actual address 0 like the zeroth byte of my RAM,"},"3676.60":{"start":"3676.6","dur":"5.61","text":"and this is 2 gigabytes all the way down here."},"3682.21":{"start":"3682.21","dur":"5.02","text":"So this page might correspond to this block over here."},"3687.23":{"start":"3687.23","dur":"2.17","text":"This page might correspond to this block over here."},"3689.40":{"start":"3689.4","dur":"2.16","text":"This one might correspond to this one over here."},"3691.56":{"start":"3691.56","dur":"3.98","text":"So the operating system is free to assign physical memory"},"3695.54":{"start":"3695.54","dur":"3.78","text":"to any individual page arbitrarily."},"3699.32":{"start":"3699.32","dur":"6.86","text":"And that means that if this border happens to straddle an array,"},"3706.18":{"start":"3706.18","dur":"3.89","text":"an array happens to be left of this and right of this order of a page,"},"3710.07":{"start":"3710.07","dur":"4.39","text":"then that array is going to be split in physical memory."},"3714.46":{"start":"3714.46","dur":"4.82","text":"And then when you quit the program, when the process ends,"},"3719.28":{"start":"3719.28","dur":"6.41","text":"these mappings get erased and then it&#39;s free to use these little blocks for other things."},"3734.73":{"start":"3734.73","dur":"2.68","text":"More questions?"},"3737.41":{"start":"3737.41","dur":"2.55","text":"[student] The pointer arithmetic. &gt;&gt;Oh yeah."},"3739.96":{"start":"3739.96","dur":"8.45","text":"Strings were easier, but looking at something like ints,"},"3748.41":{"start":"3748.41","dur":"6.59","text":"so back to int x[4];"},"3755.00":{"start":"3755","dur":"6.81","text":"Whether this is an array or whether it&#39;s a pointer to a malloced array of 4 integers,"},"3761.81":{"start":"3761.81","dur":"5.25","text":"it&#39;s going to be treated the same way."},"3770.59":{"start":"3770.59","dur":"2.75","text":"[student] So arrays are on the heap?"},"3781.40":{"start":"3781.4","dur":"3.87","text":"[Bowden] Arrays are not on the heap. &gt;&gt;[student] Oh."},"3785.27":{"start":"3785.27","dur":"3.05","text":"[Bowden] This type of array tends to be on the stack"},"3788.32":{"start":"3788.32","dur":"3.9","text":"unless you declared it at--ignoring global variables. Don&#39;t use global variables."},"3792.22":{"start":"3792.22","dur":"4.06","text":"Inside of a function I say int x[4];"},"3796.28":{"start":"3796.28","dur":"6.24","text":"It&#39;s going to create a 4-integer block on the stack for this array."},"3802.52":{"start":"3802.52","dur":"4.44","text":"But this malloc(4 * sizeof(int)); is going to go on the heap."},"3806.96":{"start":"3806.96","dur":"4.91","text":"But after this point I can use x and p in pretty much the same ways,"},"3811.87":{"start":"3811.87","dur":"4.27","text":"other than the exceptions I said before about you can reassign p."},"3816.14":{"start":"3816.14","dur":"4.82","text":"Technically, their sizes are somewhat different, but that&#39;s completely irrelevant."},"3820.96":{"start":"3820.96","dur":"2.35","text":"You never actually use their sizes."},"3828.02":{"start":"3828.02","dur":"8.79","text":"The p I could say p[3] = 2; or x[3] = 2;"},"3836.81":{"start":"3836.81","dur":"2.87","text":"You can use them in exactly the same ways."},"3839.68":{"start":"3839.68","dur":"1.89","text":"So pointer arithmetic now-- Yes."},"3841.57":{"start":"3841.57","dur":"5.82","text":"[student] Do you not have to do p* if you have the brackets?"},"3847.39":{"start":"3847.39","dur":"4.33","text":"The brackets are an implicit dereference. &gt;&gt;Okay."},"3851.72":{"start":"3851.72","dur":"8.48","text":"Actually, also what you&#39;re saying with the can you get multidimensional arrays"},"3860.20":{"start":"3860.2","dur":"42.45","text":"with pointers, what you can do is something like, let&#39;s say, int **pp = malloc(sizeof(int*) * 5);"},"3902.65":{"start":"3902.65","dur":"4.25","text":"I&#39;ll just write it all out first."},"3937.88":{"start":"3937.88","dur":"3.14","text":"I did not want that one."},"3941.02":{"start":"3941.02","dur":"1.53","text":"Okay."},"3942.55":{"start":"3942.55","dur":"6.36","text":"What I did here is-- That should be pp[i]."},"3948.91":{"start":"3948.91","dur":"4.77","text":"So pp is a pointer to a pointer."},"3953.68":{"start":"3953.68","dur":"8.74","text":"You&#39;re mallocing pp to point to an array of 5 int stars."},"3962.42":{"start":"3962.42","dur":"8.53","text":"So in memory you have on the stack pp."},"3970.95":{"start":"3970.95","dur":"9.2","text":"It&#39;s going to point to an array of 5 blocks which are all themselves pointers."},"3980.15":{"start":"3980.15","dur":"8.06","text":"And then when I malloc down here, I malloc that each of those individual pointers"},"3988.21":{"start":"3988.21","dur":"3.87","text":"should point to a separate block of 4 bytes on the heap."},"3992.08":{"start":"3992.08","dur":"3.79","text":"So this points to 4 bytes."},"3997.94":{"start":"3997.94","dur":"2.72","text":"And this one points to a different 4 bytes."},"4000.66":{"start":"4000.66","dur":"2.54","text":"And all of them point to their own 4 bytes."},"4003.20":{"start":"4003.2","dur":"5.88","text":"This gives me a way of doing multidimensional things."},"4009.08":{"start":"4009.08","dur":"8.95","text":"I could say pp[3][4], but now this is not the same thing as multidimensional arrays"},"4018.03":{"start":"4018.03","dur":"7.36","text":"because multidimensional arrays it translated [3][4] into a single offset into the x array."},"4025.39":{"start":"4025.39","dur":"9.4","text":"This dereferences p, accesses the third index, then dereferences that"},"4034.79":{"start":"4034.79","dur":"6","text":"and accesses--4 would be invalid--the second index."},"4044.77":{"start":"4044.77","dur":"6.66","text":"Whereas when we had the int x[3][4] before as a multidimensional array"},"4051.43":{"start":"4051.43","dur":"4.31","text":"and when you double bracket it&#39;s really only a single dereference,"},"4055.74":{"start":"4055.74","dur":"4.75","text":"you&#39;re following a single pointer and then an offset,"},"4060.49":{"start":"4060.49","dur":"2.36","text":"this is really 2D references."},"4062.85":{"start":"4062.85","dur":"2.99","text":"You follow 2 separate pointers."},"4065.84":{"start":"4065.84","dur":"4.58","text":"So this also technically allows you to have multidimensional arrays"},"4070.42":{"start":"4070.42","dur":"3.13","text":"where each individual array is different sizes."},"4073.55":{"start":"4073.55","dur":"4.45","text":"So I think jagged multidimensional arrays is what it&#39;s called"},"4078.00":{"start":"4078","dur":"3.87","text":"since really the first thing could point to something that has 10 elements,"},"4081.87":{"start":"4081.87","dur":"3.67","text":"the second thing could point to something that has 100 elements."},"4085.54":{"start":"4085.54","dur":"5.25","text":"[student] Is there any limit to the number of pointers you can have"},"4090.79":{"start":"4090.79","dur":"3.5","text":"pointing to other pointers? &gt;&gt;No."},"4094.29":{"start":"4094.29","dur":"2.72","text":"You can have int *****p."},"4098.05":{"start":"4098.05","dur":"5.71","text":"Back to pointer arithmetic-- &gt;&gt;[student] Oh. &gt;&gt;Yeah."},"4103.76":{"start":"4103.76","dur":"11.889","text":"[student] If I have int ***p and then I do a dereferencing and I say p* is equal to this value,"},"4115.65":{"start":"4115.649","dur":"3.911","text":"is it only going to do 1 level of dereferencing? &gt;&gt;Yes."},"4119.56":{"start":"4119.56","dur":"3.78","text":"So if I want to access the thing that the last pointer is pointing at--"},"4123.34":{"start":"4123.34","dur":"2.87","text":"Then you do ***p. &gt;&gt;Okay."},"4126.21":{"start":"4126.21","dur":"7.87","text":"So this is p points to 1 block, points to another block, points to another block."},"4134.08":{"start":"4134.08","dur":"7.93","text":"Then if you do *p = something else, then you are changing this"},"4142.01":{"start":"4142.01","dur":"11.63","text":"to now point to a different block. &gt;&gt;Okay."},"4153.64":{"start":"4153.64","dur":"4.009","text":"[Bowden] And if these were malloced, then you have now leaked memory"},"4157.65":{"start":"4157.649","dur":"2.781","text":"unless you happen to have different references of these"},"4160.43":{"start":"4160.43","dur":"4.84","text":"since you can&#39;t get back to those ones that you just threw away."},"4165.27":{"start":"4165.27","dur":"4.28","text":"Pointer arithmetic."},"4169.55":{"start":"4169.55","dur":"6.76","text":"int x[4]; is going to allocate an array of 4 integers"},"4176.31":{"start":"4176.31","dur":"4.36","text":"where x is going to point to the beginning of the array."},"4180.67":{"start":"4180.67","dur":"9.75","text":"So when I say something like x[1]; I want it to mean go to the second integer in the array,"},"4190.42":{"start":"4190.42","dur":"2.899","text":"which would be this one."},"4193.32":{"start":"4193.319","dur":"10.871","text":"But really, that&#39;s 4 bytes into the array since this integer takes up 4 bytes."},"4204.19":{"start":"4204.19","dur":"4.28","text":"So an offset of 1 really means an offset of 1"},"4208.47":{"start":"4208.47","dur":"3.56","text":"times the size of whatever the type of the array is."},"4212.03":{"start":"4212.03","dur":"5.14","text":"This is an array of integers, so it knows to do 1 times size of int when it wants to offset."},"4217.17":{"start":"4217.17","dur":"8.09","text":"The other syntax. Remember that this is equivalent to *(x + 1);"},"4225.26":{"start":"4225.26","dur":"9.99","text":"When I say pointer + 1, what that returns is the address that the pointer is storing"},"4235.25":{"start":"4235.25","dur":"5.11","text":"plus 1 times the size of the type of the pointer."},"4240.36":{"start":"4240.36","dur":"19.15","text":"So if x = ox100, then x + 1 = ox104."},"4259.51":{"start":"4259.51","dur":"20.24","text":"And you can abuse this and say something like char* c = (char*)x;"},"4279.75":{"start":"4279.75","dur":"3.3","text":"and now c is going to be the same address as x."},"4283.05":{"start":"4283.05","dur":"2.99","text":"c is going to be equal to ox100,"},"4286.04":{"start":"4286.04","dur":"5.45","text":"but c + 1 is going to be equal to ox101"},"4291.49":{"start":"4291.49","dur":"6.54","text":"since pointer arithmetic depends on the type of the pointer that you are adding to."},"4298.03":{"start":"4298.03","dur":"7.36","text":"So c + 1, it looks at c, it&#39;s a char pointer, so it&#39;s going to add 1 times size of char,"},"4305.39":{"start":"4305.39","dur":"2.72","text":"which is always going to be 1, so you get 101,"},"4308.11":{"start":"4308.11","dur":"6.78","text":"whereas if I do x, which is also still 100, x + 1 is going to be 104."},"4316.66":{"start":"4316.66","dur":"9.68","text":"[student] Can you use c++ in order to advance your pointer by 1?"},"4326.34":{"start":"4326.34","dur":"3.47","text":"Yes, you can."},"4329.81":{"start":"4329.81","dur":"6.37","text":"You can&#39;t do that with x because x is just a symbol, it is a constant; you can&#39;t change x."},"4336.18":{"start":"4336.18","dur":"6.43","text":"But c happens to just be a pointer, so c++ is perfectly valid and it will increment by 1."},"4342.61":{"start":"4342.61","dur":"9.83","text":"If c were just an int *, then c++ would be 104."},"4352.44":{"start":"4352.44","dur":"8.81","text":"++ does pointer arithmetic just as c + 1 would have done pointer arithmetic."},"4363.00":{"start":"4363","dur":"5.87","text":"This is actually how a lot of things like merge sort--"},"4369.67":{"start":"4369.67","dur":"6.04","text":"Instead of creating copies of things, you can instead pass--"},"4375.71":{"start":"4375.71","dur":"6.69","text":"Like if I wanted to pass this half of the array--let&#39;s erase some of this."},"4384.77":{"start":"4384.77","dur":"5.75","text":"Let&#39;s say I wanted to pass this side of the array into a function."},"4390.52":{"start":"4390.52","dur":"2.18","text":"What would I pass to that function?"},"4392.70":{"start":"4392.7","dur":"4.35","text":"If I pass x, I am passing this address."},"4397.05":{"start":"4397.05","dur":"6.73","text":"But I want to pass this particular address. So what should I pass?"},"4403.78":{"start":"4403.78","dur":"2.81","text":"[student] Pointer + 2?"},"4406.59":{"start":"4406.59","dur":"2.76","text":"[Bowden] So x + 2. Yes."},"4409.35":{"start":"4409.35","dur":"2.27","text":"That&#39;s going to be this address."},"4411.62":{"start":"4411.62","dur":"11.19","text":"You&#39;ll also very frequently see it as x[2] and then the address of that."},"4422.81":{"start":"4422.81","dur":"5.04","text":"So you need to take the address of it because the bracket is an implicit dereference."},"4427.85":{"start":"4427.85","dur":"5.4","text":"x[2] refers to the value that is in this box, and then you want the address of that box,"},"4433.25":{"start":"4433.25","dur":"3.6","text":"so you say &amp;x[2]."},"4436.85":{"start":"4436.85","dur":"6.03","text":"So that&#39;s how something in merge sort where you want to pass half the list to something"},"4442.88":{"start":"4442.88","dur":"5.91","text":"you really just pass &amp;x[2], and now as far as the recursive call is concerned,"},"4448.79":{"start":"4448.79","dur":"3.72","text":"my new array starts there."},"4452.51":{"start":"4452.51","dur":"2.62","text":"Last minute questions."},"4455.13":{"start":"4455.13","dur":"4.92","text":"[student] If we don&#39;t put an ampersand or a--what&#39;s that called? &gt;&gt;Star?"},"4460.05":{"start":"4460.05","dur":"3.15","text":"[student] Star. &gt;&gt;Technically, dereference operator, but-- &gt;&gt;[student] Dereference."},"4463.20":{"start":"4463.2","dur":"6.11","text":"If we don&#39;t put a star or an ampersand, what happens if I just say y = x and x is a pointer?"},"4469.31":{"start":"4469.31","dur":"5.31","text":"What is the type of y? &gt;&gt;[student] I&#39;ll just say it&#39;s pointer 2."},"4474.62":{"start":"4474.62","dur":"3.65","text":"So if you just say y = x, now x and y point to the same thing. &gt;&gt;[student] Point to the same thing."},"4478.27":{"start":"4478.27","dur":"6.91","text":"And if x is an int pointer? &gt;&gt;It would complain because you can&#39;t assign pointers."},"4485.18":{"start":"4485.18","dur":"1.36","text":"[student] Okay."},"4486.54":{"start":"4486.54","dur":"5.32","text":"Remember that pointers, even though we draw them as arrows,"},"4491.86":{"start":"4491.86","dur":"10.15","text":"really all they store--int *x--really all x is storing is something like ox100,"},"4502.01":{"start":"4502.01","dur":"4.48","text":"which we happen to represent as pointing to the block stored at 100."},"4506.49":{"start":"4506.49","dur":"13.17","text":"So when I say int *y = x; I&#39;m just copying ox100 into y,"},"4519.66":{"start":"4519.66","dur":"4.97","text":"which we&#39;re just going to represent as y, also pointing to ox100."},"4524.63":{"start":"4524.63","dur":"15.18","text":"And if I say int i = (int)x; then i is going to store whatever the value of ox100 is"},"4539.81":{"start":"4539.81","dur":"5.29","text":"inside of it, but now it&#39;s going to be interpreted as an integer instead of a pointer."},"4545.10":{"start":"4545.1","dur":"4.21","text":"But you need the cast or else it will complain."},"4549.31":{"start":"4549.31","dur":"3.99","text":"[student] So do you mean to cast--"},"4553.30":{"start":"4553.3","dur":"6.99","text":"Is it going to be casting int of x or casting int of y?"},"4560.29":{"start":"4560.29","dur":"3.41","text":"[Bowden] What?"},"4563.70":{"start":"4563.7","dur":"3.99","text":"[student] Okay. After these parentheses is there going to be an x or a y there?"},"4567.69":{"start":"4567.69","dur":"3.81","text":"[Bowden] Either. x and y are equivalent. &gt;&gt;[student] Okay."},"4571.50":{"start":"4571.5","dur":"2.89","text":"Because they&#39;re both pointers. &gt;&gt;Yeah."},"4574.39":{"start":"4574.39","dur":"6.66","text":"[student] So it would store the hexadecimal 100 in integer form? &gt;&gt;[Bowden] Yeah."},"4581.05":{"start":"4581.05","dur":"2.57","text":"But not the value of whatever it points to."},"4583.62":{"start":"4583.62","dur":"6.32","text":"[Bowden] Yeah. &gt;&gt;[student] So just the address in integer form. Okay."},"4589.94":{"start":"4589.94","dur":"4.78","text":"[Bowden] If you wanted to for some bizarre reason,"},"4594.72":{"start":"4594.72","dur":"4.18","text":"you could exclusively deal with pointers and never deal with integers"},"4598.90":{"start":"4598.9","dur":"10.34","text":"and just be like int *x = 0."},"4609.24":{"start":"4609.24","dur":"3.76","text":"Then you&#39;re going to get really confused once pointer arithmetic starts happening."},"4613.00":{"start":"4613","dur":"3.57","text":"So the numbers that they store are meaningless."},"4616.57":{"start":"4616.57","dur":"2.37","text":"It&#39;s just how you end up interpreting them."},"4618.94":{"start":"4618.94","dur":"3.98","text":"So I&#39;m free to copy ox100 from an int * to an int,"},"4622.92":{"start":"4622.92","dur":"4.87","text":"and I&#39;m free to assign--you&#39;re probably going to get yelled at for not casting--"},"4627.79":{"start":"4627.79","dur":"10.37","text":"I&#39;m free to assign something like (int *)ox1234 into this arbitrary int *."},"4638.16":{"start":"4638.16","dur":"7.32","text":"So ox123 is just as valid a memory address as is &amp;y."},"4645.48":{"start":"4645.48","dur":"6.58","text":"&amp;y happens to return something that is pretty much ox123."},"4652.06":{"start":"4652.06","dur":"3.37","text":"[student] Would that be a really cool way to go from hexadecimal to decimal form,"},"4655.43":{"start":"4655.43","dur":"3.8","text":"like if you have a pointer and you cast it as an int?"},"4659.23":{"start":"4659.23","dur":"5.63","text":"[Bowden] You can really just print using like printf."},"4664.86":{"start":"4664.86","dur":"5.44","text":"Let&#39;s say I have int y = 100."},"4670.30":{"start":"4670.3","dur":"12.4","text":"So printf(%d\\n--as you should already know--print that as an integer, %x."},"4682.70":{"start":"4682.7","dur":"2.49","text":"We&#39;ll just print it as hexadecimal."},"4685.19":{"start":"4685.19","dur":"5.57","text":"So a pointer is not stored as hexadecimal,"},"4690.76":{"start":"4690.76","dur":"2.2","text":"and an integer is not stored as decimal."},"4692.96":{"start":"4692.96","dur":"1.74","text":"Everything is stored as binary."},"4694.70":{"start":"4694.7","dur":"3.25","text":"It&#39;s just that we tend to show pointers as hexadecimal"},"4697.95":{"start":"4697.95","dur":"5.31","text":"because we think of things in these 4-byte blocks,"},"4703.26":{"start":"4703.26","dur":"2.13","text":"and memory addresses tend to be familiar."},"4705.39":{"start":"4705.39","dur":"3.5","text":"We&#39;re like, if it starts with bf, then it happens to be on the stack."},"4708.89":{"start":"4708.89","dur":"6.67","text":"So it&#39;s just our interpretation of pointers as hexadecimal."},"4715.56":{"start":"4715.56","dur":"3.64","text":"Okay. Any last questions?"},"4719.20":{"start":"4719.2","dur":"2.5","text":"I&#39;ll be here for a bit after if you have anything else."},"4721.70":{"start":"4721.7","dur":"4.37","text":"And that&#39;s the end of that."},"4726.07":{"start":"4726.07","dur":"2.29","text":"[student] Yay! [applause]"},"4731.44":{"start":"4731.44","dur":"1.56","text":"[CS50.TV]"}}