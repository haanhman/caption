{"3":{"dur":2,"text":"Hi, I\u2019m Carrie Anne and welcome to Crash\nCourse Computer Science."},"5":{"dur":5,"text":"So last episode, using just logic gates, we\nbuilt a simple ALU, which performs arithmetic"},"11":{"dur":2,"text":"and logic operations, hence the \u2018A\u2019 and\nthe \u2018L\u2019."},"13":{"dur":3,"text":"But of course, there\u2019s not much point in\ncalculating a result only to throw it away"},"17":{"dur":5,"text":"- it would be useful to store that value somehow, and maybe even run several operations in a row."},"22":{"dur":2,"text":"That's where computer memory comes in!"},"24":{"dur":3,"text":"If you've ever been in the middle of a long\nRPG campaign on your console, or slogging"},"28":{"dur":4,"text":"through a difficult level on Minesweeper on\nyour desktop, and your dog came by, tripped"},"32":{"dur":4,"text":"and pulled the power cord out of the wall,\nyou know the agony of losing all your progress."},"36":{"dur":1,"text":"Condolences."},"38":{"dur":3,"text":"But the reason for your loss is that your\nconsole, your laptop and your computers make"},"42":{"dur":4,"text":"use of Random Access Memory, or RAM, which\nstores things like game state - as long as"},"46":{"dur":1,"text":"the power stays on."},"47":{"dur":3,"text":"Another type of memory, called persistent\nmemory, can survive without power, and it\u2019s"},"51":{"dur":3,"text":"used for different things; We'll talk about\nthe persistence of memory in a later episode."},"55":{"dur":4,"text":"Today, we\u2019re going to start small - literally by building a circuit that can store one.."},"60":{"dur":1,"text":"single.. bit of information."},"61":{"dur":4,"text":"After that, we\u2019ll scale up, and build our\nvery own memory module, and we\u2019ll combine"},"65":{"dur":4,"text":"it with our ALU next time, when we finally\nbuild our very own CPU!"},"70":{"dur":9,"text":"INTRO"},"79":{"dur":3,"text":"All of the logic circuits we've discussed\nso far go in one direction - always flowing"},"83":{"dur":3,"text":"forward - like our 8-bit ripple adder from\nlast episode."},"86":{"dur":3,"text":"But we can also create circuits that loop\nback on themselves."},"89":{"dur":4,"text":"Let\u2019s try taking an ordinary OR gate, and\nfeed the output back into one of its inputs"},"94":{"dur":1,"text":"and see what happens."},"95":{"dur":2,"text":"First, let\u2019s set both inputs to 0."},"97":{"dur":4,"text":"So 0 OR 0 is 0, and so this circuit always\noutputs 0."},"101":{"dur":2,"text":"If we were to flip input A to 1."},"104":{"dur":4,"text":"1 OR 0 is 1, so now the output of the OR gate\nis 1."},"108":{"dur":4,"text":"A fraction of a second later, that loops back\naround into input B, so the OR gate sees that"},"112":{"dur":1,"text":"both of its inputs are now 1."},"114":{"dur":3,"text":"1 OR 1 is still 1, so there is no change in\noutput."},"118":{"dur":3,"text":"If we flip input A back to 0, the OR gate\nstill outputs 1."},"121":{"dur":2,"text":"So now we've got a circuit that records a\n\u201c1\u201d for us."},"124":{"dur":3,"text":"Except, we've got a teensy tiny problem - this\nchange is permanent!"},"127":{"dur":4,"text":"No matter how hard we try, there\u2019s no way\nto get this circuit to flip back from a 1"},"132":{"dur":1,"text":"to a 0."},"133":{"dur":2,"text":"Now let\u2019s look at this same circuit, but\nwith an AND gate instead."},"136":{"dur":2,"text":"We'll start inputs A and B both at 1."},"139":{"dur":2,"text":"1 AND 1 outputs 1 forever."},"141":{"dur":4,"text":"But, if we then flip input A to 0, because\nit\u2019s an AND gate, the output will go to 0."},"146":{"dur":3,"text":"So this circuit records a 0, the opposite\nof our other circuit."},"149":{"dur":5,"text":"Like before, no matter what input we apply\nto input A afterwards, the circuit will always output 0."},"154":{"dur":3,"text":"Now we\u2019ve got circuits that can record both\n0s and 1s."},"158":{"dur":4,"text":"The key to making this a useful piece of memory\nis to combine our two circuits into what is"},"162":{"dur":1,"text":"called the AND-OR Latch."},"164":{"dur":4,"text":"It has two inputs, a \"set\" input, which sets\nthe output to a 1, and a \"reset\" input, which"},"168":{"dur":1,"text":"resets the output to a 0."},"170":{"dur":4,"text":"If set and reset are both 0, the circuit just\noutputs whatever was last put in it."},"174":{"dur":3,"text":"In other words, it remembers a single bit\nof information!"},"178":{"dur":1,"text":"Memory!"},"179":{"dur":4,"text":"This is called a \u201clatch\u201d because it \u201clatches\nonto\u201d a particular value and stays that way."},"183":{"dur":4,"text":"The action of putting data into memory is\ncalled writing, whereas getting the data out"},"188":{"dur":0,"text":"is called reading."},"189":{"dur":2,"text":"Ok, so we\u2019ve got a way to store a single\nbit of information!"},"192":{"dur":1,"text":"Great!"},"193":{"dur":4,"text":"Unfortunately, having two different wires\nfor input \u2013 set and reset \u2013 is a bit confusing."},"198":{"dur":4,"text":"To make this a little easier to use, we really\nwant a single wire to input data, that we"},"202":{"dur":2,"text":"can set to either 0 or 1 to store the value."},"204":{"dur":3,"text":"Additionally, we are going to need a wire\nthat enables the memory to be either available"},"208":{"dur":4,"text":"for writing or \u201clocked\u201d down --which is\ncalled the write enable line."},"212":{"dur":4,"text":"By adding a few extra logic gates, we can\nbuild this circuit, which is called a Gated Latch"},"217":{"dur":1,"text":"since the \u201cgate\u201d can be opened or\nclosed."},"219":{"dur":2,"text":"Now this circuit is starting to get a little\ncomplicated."},"221":{"dur":3,"text":"We don\u2019t want to have to deal with all the\nindividual logic gates... so as before, we\u2019re"},"224":{"dur":4,"text":"going to bump up a level of abstraction, and\nput our whole Gated Latch circuit in a box"},"228":{"dur":1,"text":"-- a box that stores one bit."},"230":{"dur":2,"text":"Let\u2019s test out our new component!"},"232":{"dur":1,"text":"Let\u2019s start everything at 0."},"234":{"dur":5,"text":"If we toggle the Data wire from 0 to 1 or\n1 to 0, nothing happens - the output stays at 0."},"240":{"dur":3,"text":"That\u2019s because the write enable wire is\noff, which prevents any change to the memory."},"244":{"dur":3,"text":"So we need to \u201copen\u201d the \u201cgate\u201d by\nturning the write enable wire to 1."},"247":{"dur":3,"text":"Now we can put a 1 on the data line to save\nthe value 1 to our latch."},"251":{"dur":2,"text":"Notice how the output is now 1."},"254":{"dur":3,"text":"We can turn off the enable line and the output\nstays as 1."},"258":{"dur":3,"text":"Once again, we can toggle the value on the\ndata line all we want, but the output will"},"261":{"dur":1,"text":"stay the same."},"262":{"dur":2,"text":"The value is saved in memory."},"264":{"dur":4,"text":"Now let\u2019s turn the enable line on again\nuse our data line to set the latch to 0."},"269":{"dur":1,"text":"Done."},"270":{"dur":2,"text":"Enable line off, and the output is 0."},"272":{"dur":1,"text":"And it works!"},"273":{"dur":3,"text":"Now, of course, computer memory that only\nstores one bit of information isn\u2019t very"},"277":{"dur":2,"text":"useful -- definitely not enough to run Frogger."},"279":{"dur":1,"text":"Or anything, really."},"281":{"dur":2,"text":"But we\u2019re not limited to using only one\nlatch."},"283":{"dur":4,"text":"If we put 8 latches side-by-side, we can store\n8 bits of information like an 8-bit number."},"288":{"dur":5,"text":"A group of latches operating like this is\ncalled a register, which holds a single number,"},"293":{"dur":2,"text":"and the number of bits in a register is called\nits width."},"296":{"dur":5,"text":"Early computers had 8-bit registers, then\n16, 32, and today, many computers have registers"},"301":{"dur":1,"text":"that are 64-bits wide."},"303":{"dur":3,"text":"To write to our register, we first have to\nenable all of the latches."},"306":{"dur":5,"text":"We can do this with a single wire that connects to all of their enable inputs, which we set to 1."},"311":{"dur":5,"text":"We then send our data in using the 8 data\nwires, and then set enable back to 0, and"},"317":{"dur":2,"text":"the 8 bit value is now saved in memory."},"319":{"dur":3,"text":"Putting latches side-by-side works ok for\na small-ish number of bits."},"323":{"dur":5,"text":"A 64-bit register would need 64 wires running\nto the data pins, and 64 wires running to"},"328":{"dur":1,"text":"the outputs."},"329":{"dur":6,"text":"Luckily we only need 1 wire to enable all\nthe latches, but that\u2019s still 129 wires."},"336":{"dur":4,"text":"For 256 bits, we end up with 513 wires!"},"340":{"dur":1,"text":"The solution is a matrix!"},"342":{"dur":4,"text":"In this matrix, we don\u2019t arrange our latches\nin a row, we put them in a grid."},"346":{"dur":6,"text":"For 256 bits, we need a 16 by 16 grid of latches\nwith 16 rows and columns of wires."},"352":{"dur":4,"text":"To activate any one latch, we must turn on\nthe corresponding row AND column wire."},"356":{"dur":1,"text":"Let\u2019s zoom in and see how this works."},"358":{"dur":3,"text":"We only want the latch at the intersection\nof the two active wires to be enabled,"},"362":{"dur":2,"text":"but all of the other latches should stay disabled."},"365":{"dur":2,"text":"For this, we can use our trusty AND gate!"},"368":{"dur":4,"text":"The AND gate will output a 1 only if the row\nand the column wires are both 1."},"372":{"dur":3,"text":"So we can use this signal to uniquely select\na single latch."},"375":{"dur":5,"text":"This row\/column setup connects all our latches\nwith a single, shared, write enable wire."},"380":{"dur":3,"text":"In order for a latch to become write enabled,\nthe row wire, the column wire, and the write"},"384":{"dur":1,"text":"enable wire must all be 1."},"386":{"dur":3,"text":"That should only ever be true for one single\nlatch at any given time."},"389":{"dur":2,"text":"This means we can use a single, shared wire\nfor data."},"392":{"dur":4,"text":"Because only one latch will ever be write\nenabled, only one will ever save the data"},"397":{"dur":3,"text":"-- the rest of the latches will simply ignore\nvalues on the data wire because they are not"},"400":{"dur":1,"text":"write enabled."},"401":{"dur":4,"text":"We can use the same trick with a read enable\nwire to read the data later, to get the data"},"406":{"dur":2,"text":"out of one specific latch."},"408":{"dur":6,"text":"This means in total, for 256 bits of memory,\nwe only need 35 wires - 1 data wire, 1 write"},"415":{"dur":4,"text":"enable wire, 1 read enable wire, and 16 rows\nand columns for the selection."},"419":{"dur":1,"text":"That\u2019s significant wire savings!"},"421":{"dur":3,"text":"But we need a way to uniquely specify each\nintersection."},"425":{"dur":3,"text":"We can think of this like a city, where you\nmight want to meet someone at 12th avenue"},"428":{"dur":3,"text":"and 8th street -- that's an address that defines\nan intersection."},"431":{"dur":4,"text":"The latch we just saved our one bit into has\nan address of row 12 and column 8."},"435":{"dur":4,"text":"Since there is a maximum of 16 rows, we store the row address in a 4 bit number."},"440":{"dur":2,"text":"12 is 1100 in binary."},"443":{"dur":4,"text":"We can do the same for the column address: 8 is 1000 in binary."},"448":{"dur":6,"text":"So the address for the particular latch we\njust used can be written as 11001000."},"455":{"dur":3,"text":"To convert from an address into something\nthat selects the right row or column, we need"},"459":{"dur":4,"text":"a special component called a multiplexer -- which\nis the computer component with a pretty cool"},"463":{"dur":2,"text":"name at least compared to the ALU."},"465":{"dur":4,"text":"Multiplexers come in all different sizes,\nbut because we have 16 rows, we need a 1 to"},"470":{"dur":0,"text":"16 multiplexer."},"471":{"dur":1,"text":"It works like this."},"472":{"dur":4,"text":"You feed it a 4 bit number, and it connects\nthe input line to a corresponding output line."},"476":{"dur":5,"text":"So if we pass in 0000, it will select the\nvery first column for us."},"482":{"dur":4,"text":"If we pass in 0001, the next column is selected,\nand so on."},"486":{"dur":4,"text":"We need one multiplexer to handle our rows\nand another multiplexer to handle the columns."},"490":{"dur":5,"text":"Ok, it\u2019s starting to get complicated again,\nso let\u2019s make our 256-bit memory its own component."},"496":{"dur":8,"text":"Once again a new level of abstraction!"},"504":{"dur":4,"text":"It takes an 8-bit address for input - the\n4 bits for the column and 4 for the row."},"509":{"dur":2,"text":"We also need write and read enable wires."},"512":{"dur":4,"text":"And finally, we need just one data wire, which\ncan be used to read or write data."},"517":{"dur":5,"text":"Unfortunately, even 256-bits of memory isn\u2019t\nenough to run much of anything, so we need"},"522":{"dur":1,"text":"to scale up even more!"},"523":{"dur":2,"text":"We\u2019re going to put them in a row."},"525":{"dur":1,"text":"Just like with the registers."},"526":{"dur":4,"text":"We\u2019ll make a row of 8 of them, so we can\nstore an 8 bit number - also known as a byte."},"531":{"dur":5,"text":"To do this, we feed the exact same address\ninto all 8 of our 256-bit memory components"},"537":{"dur":4,"text":"at the same time, and each one saves one bit\nof the number."},"541":{"dur":6,"text":"That means the component we just made can\nstore 256 bytes at 256 different addresses."},"547":{"dur":3,"text":"Again, to keep things simple, we want to leave\nbehind this inner complexity."},"551":{"dur":4,"text":"Instead of thinking of this as a series of\nindividual memory modules and circuits, we\u2019ll"},"555":{"dur":2,"text":"think of it as a uniform bank of addressable\nmemory."},"558":{"dur":5,"text":"We have 256 addresses, and at each address,\nwe can read or write an 8-bit value."},"563":{"dur":4,"text":"We\u2019re going to use this memory component\nnext episode when we build our CPU."},"568":{"dur":4,"text":"The way that modern computers scale to megabytes\nand gigabytes of memory is by doing the same"},"572":{"dur":4,"text":"thing we\u2019ve been doing here -- keep packaging\nup little bundles of memory into larger, and"},"576":{"dur":1,"text":"larger, and larger arrangements."},"577":{"dur":4,"text":"As the number of memory locations grow, our\naddresses have to grow as well."},"582":{"dur":6,"text":"8 bits hold enough numbers to provide addresses for 256 bytes of our memory, but that\u2019s all."},"588":{"dur":5,"text":"To address a gigabyte \u2013 or a billion bytes\nof memory \u2013 we need 32-bit addresses."},"593":{"dur":4,"text":"An important property of this memory is that\nwe can access any memory location, at any"},"598":{"dur":1,"text":"time, and in a random order."},"599":{"dur":3,"text":"For this reason, it\u2019s called Random-Access\nMemory or RAM."},"603":{"dur":4,"text":"When you hear people talking about how much RAM a computer has - that's the computer\u2019s memory."},"607":{"dur":3,"text":"RAM is like a human\u2019s short term or working\nmemory, where you keep track of things going"},"611":{"dur":3,"text":"on right now - like whether or not you had\nlunch or paid your phone bill."},"614":{"dur":3,"text":"Here\u2019s an actual stick of RAM - with 8 memory\nmodules soldered onto the board."},"618":{"dur":3,"text":"If we carefully opened up one of these modules\nand zoomed in, The first thing you would see"},"622":{"dur":1,"text":"are 32 squares of memory."},"623":{"dur":4,"text":"Zoom into one of those squares, and we can\nsee each one is comprised of 4 smaller blocks."},"628":{"dur":3,"text":"If we zoom in again, we get down to the matrix\nof individual bits."},"631":{"dur":3,"text":"This is a matrix of 128 by 64 bits."},"634":{"dur":3,"text":"That\u2019s 8192 bits in total."},"637":{"dur":6,"text":"Each of our 32 squares has 4 matrices, so\nthat\u2019s 32 thousand, 7 hundred and 68 bits."},"643":{"dur":1,"text":"And there are 32 squares in total."},"645":{"dur":4,"text":"So all in all, that\u2019s roughly 1 million\nbits of memory in each chip."},"649":{"dur":4,"text":"Our RAM stick has 8 of these chips, so in\ntotal, this RAM can store 8 millions bits,"},"654":{"dur":1,"text":"otherwise known as 1 megabyte."},"656":{"dur":3,"text":"That\u2019s not a lot of memory these days -- this\nis a RAM module from the 1980\u2019s."},"660":{"dur":5,"text":"Today you can buy RAM that has a gigabyte\nor more of memory - that\u2019s billions of bytes"},"665":{"dur":0,"text":"of memory."},"666":{"dur":4,"text":"So, today, we built a piece of SRAM - Static\nRandom-Access Memory \u2013 which uses latches."},"671":{"dur":4,"text":"There are other types of RAM, such as DRAM, Flash memory, and NVRAM."},"675":{"dur":4,"text":"These are very similar in function to SRAM,\nbut use different circuits to store the individual"},"679":{"dur":4,"text":"bits -- for example, using different logic\ngates, capacitors, charge traps, or memristors."},"684":{"dur":4,"text":"But fundamentally, all of these technologies\nstore bits of information in massively nested"},"688":{"dur":2,"text":"matrices of memory cells."},"691":{"dur":4,"text":"Like many things in computing, the fundamental\noperation is relatively simple.. it\u2019s the"},"695":{"dur":4,"text":"layers and layers of abstraction that\u2019s\nmind blowing -- like a russian doll that"},"700":{"dur":2,"text":"keeps getting smaller and smaller and smaller."},"702":{"dur":1,"text":"I\u2019ll see you next week."},"704":{"dur":21,"text":"Credits"}}