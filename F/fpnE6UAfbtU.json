{"3.18":{"start":"3.18","dur":"2.6","text":"Hi, I\u2019m Carrie Anne and welcome to Crash\nCourse Computer Science."},"5.79":{"start":"5.79","dur":"5.23","text":"So last episode, using just logic gates, we\nbuilt a simple ALU, which performs arithmetic"},"11.03":{"start":"11.03","dur":"2.939","text":"and logic operations, hence the \u2018A\u2019 and\nthe \u2018L\u2019."},"13.97":{"start":"13.969","dur":"3.391","text":"But of course, there\u2019s not much point in\ncalculating a result only to throw it away"},"17.36":{"start":"17.36","dur":"5.28","text":"- it would be useful to store that value somehow, and maybe even run several operations in a row."},"22.74":{"start":"22.74","dur":"2.1","text":"That&#39;s where computer memory comes in!"},"24.85":{"start":"24.85","dur":"3.79","text":"If you&#39;ve ever been in the middle of a long\nRPG campaign on your console, or slogging"},"28.65":{"start":"28.65","dur":"4.29","text":"through a difficult level on Minesweeper on\nyour desktop, and your dog came by, tripped"},"32.94":{"start":"32.94","dur":"4.04","text":"and pulled the power cord out of the wall,\nyou know the agony of losing all your progress."},"36.98":{"start":"36.98","dur":"1.22","text":"Condolences."},"38.20":{"start":"38.2","dur":"3.8","text":"But the reason for your loss is that your\nconsole, your laptop and your computers make"},"42.01":{"start":"42.01","dur":"4.53","text":"use of Random Access Memory, or RAM, which\nstores things like game state - as long as"},"46.54":{"start":"46.54","dur":"1.18","text":"the power stays on."},"47.72":{"start":"47.72","dur":"3.94","text":"Another type of memory, called persistent\nmemory, can survive without power, and it\u2019s"},"51.68":{"start":"51.68","dur":"3.979","text":"used for different things; We&#39;ll talk about\nthe persistence of memory in a later episode."},"55.66":{"start":"55.66","dur":"4.35","text":"Today, we\u2019re going to start small - literally by building a circuit that can store one.."},"60.01":{"start":"60.01","dur":"1.71","text":"single.. bit of information."},"61.72":{"start":"61.72","dur":"4.04","text":"After that, we\u2019ll scale up, and build our\nvery own memory module, and we\u2019ll combine"},"65.76":{"start":"65.76","dur":"4.54","text":"it with our ALU next time, when we finally\nbuild our very own CPU!"},"70.30":{"start":"70.3","dur":"9.06","text":"INTRO"},"79.37":{"start":"79.37","dur":"3.92","text":"All of the logic circuits we&#39;ve discussed\nso far go in one direction - always flowing"},"83.29":{"start":"83.29","dur":"3.18","text":"forward - like our 8-bit ripple adder from\nlast episode."},"86.47":{"start":"86.47","dur":"3.19","text":"But we can also create circuits that loop\nback on themselves."},"89.66":{"start":"89.66","dur":"4.53","text":"Let\u2019s try taking an ordinary OR gate, and\nfeed the output back into one of its inputs"},"94.19":{"start":"94.19","dur":"1.04","text":"and see what happens."},"95.23":{"start":"95.23","dur":"2.2","text":"First, let\u2019s set both inputs to 0."},"97.43":{"start":"97.43","dur":"4.54","text":"So 0 OR 0 is 0, and so this circuit always\noutputs 0."},"101.97":{"start":"101.97","dur":"2.04","text":"If we were to flip input A to 1."},"104.01":{"start":"104.01","dur":"4.4","text":"1 OR 0 is 1, so now the output of the OR gate\nis 1."},"108.41":{"start":"108.41","dur":"4.54","text":"A fraction of a second later, that loops back\naround into input B, so the OR gate sees that"},"112.95":{"start":"112.95","dur":"1.72","text":"both of its inputs are now 1."},"114.67":{"start":"114.67","dur":"3.66","text":"1 OR 1 is still 1, so there is no change in\noutput."},"118.33":{"start":"118.33","dur":"3.66","text":"If we flip input A back to 0, the OR gate\nstill outputs 1."},"121.99":{"start":"121.99","dur":"2.62","text":"So now we&#39;ve got a circuit that records a\n\u201c1\u201d for us."},"124.61":{"start":"124.61","dur":"3.3","text":"Except, we&#39;ve got a teensy tiny problem - this\nchange is permanent!"},"127.91":{"start":"127.91","dur":"4.73","text":"No matter how hard we try, there\u2019s no way\nto get this circuit to flip back from a 1"},"132.64":{"start":"132.64","dur":"1","text":"to a 0."},"133.64":{"start":"133.64","dur":"2.859","text":"Now let\u2019s look at this same circuit, but\nwith an AND gate instead."},"136.50":{"start":"136.499","dur":"2.74","text":"We&#39;ll start inputs A and B both at 1."},"139.24":{"start":"139.24","dur":"2.13","text":"1 AND 1 outputs 1 forever."},"141.37":{"start":"141.37","dur":"4.87","text":"But, if we then flip input A to 0, because\nit\u2019s an AND gate, the output will go to 0."},"146.30":{"start":"146.3","dur":"3.52","text":"So this circuit records a 0, the opposite\nof our other circuit."},"149.82":{"start":"149.82","dur":"5.1","text":"Like before, no matter what input we apply\nto input A afterwards, the circuit will always output 0."},"154.98":{"start":"154.98","dur":"3.24","text":"Now we\u2019ve got circuits that can record both\n0s and 1s."},"158.23":{"start":"158.23","dur":"4.11","text":"The key to making this a useful piece of memory\nis to combine our two circuits into what is"},"162.34":{"start":"162.34","dur":"1.759","text":"called the AND-OR Latch."},"164.10":{"start":"164.099","dur":"4.381","text":"It has two inputs, a &quot;set&quot; input, which sets\nthe output to a 1, and a &quot;reset&quot; input, which"},"168.48":{"start":"168.48","dur":"1.92","text":"resets the output to a 0."},"170.40":{"start":"170.4","dur":"4.56","text":"If set and reset are both 0, the circuit just\noutputs whatever was last put in it."},"174.96":{"start":"174.96","dur":"3.24","text":"In other words, it remembers a single bit\nof information!"},"178.20":{"start":"178.2","dur":"1.24","text":"Memory!"},"179.44":{"start":"179.44","dur":"4.3","text":"This is called a \u201clatch\u201d because it \u201clatches\nonto\u201d a particular value and stays that way."},"183.78":{"start":"183.78","dur":"4.74","text":"The action of putting data into memory is\ncalled writing, whereas getting the data out"},"188.52":{"start":"188.52","dur":"0.999","text":"is called reading."},"189.52":{"start":"189.519","dur":"2.991","text":"Ok, so we\u2019ve got a way to store a single\nbit of information!"},"192.51":{"start":"192.51","dur":"1","text":"Great!"},"193.51":{"start":"193.51","dur":"4.8","text":"Unfortunately, having two different wires\nfor input \u2013 set and reset \u2013 is a bit confusing."},"198.31":{"start":"198.31","dur":"4.539","text":"To make this a little easier to use, we really\nwant a single wire to input data, that we"},"202.85":{"start":"202.849","dur":"2.101","text":"can set to either 0 or 1 to store the value."},"204.95":{"start":"204.95","dur":"3.84","text":"Additionally, we are going to need a wire\nthat enables the memory to be either available"},"208.79":{"start":"208.79","dur":"4.11","text":"for writing or \u201clocked\u201d down --which is\ncalled the write enable line."},"212.90":{"start":"212.9","dur":"4.48","text":"By adding a few extra logic gates, we can\nbuild this circuit, which is called a Gated Latch"},"217.40":{"start":"217.4","dur":"1.72","text":"since the \u201cgate\u201d can be opened or\nclosed."},"219.13":{"start":"219.129","dur":"2.61","text":"Now this circuit is starting to get a little\ncomplicated."},"221.74":{"start":"221.739","dur":"3.2","text":"We don\u2019t want to have to deal with all the\nindividual logic gates... so as before, we\u2019re"},"224.94":{"start":"224.939","dur":"4.04","text":"going to bump up a level of abstraction, and\nput our whole Gated Latch circuit in a box"},"228.98":{"start":"228.979","dur":"1.87","text":"-- a box that stores one bit."},"230.85":{"start":"230.849","dur":"2.04","text":"Let\u2019s test out our new component!"},"232.89":{"start":"232.889","dur":"1.761","text":"Let\u2019s start everything at 0."},"234.65":{"start":"234.65","dur":"5.83","text":"If we toggle the Data wire from 0 to 1 or\n1 to 0, nothing happens - the output stays at 0."},"240.58":{"start":"240.58","dur":"3.62","text":"That\u2019s because the write enable wire is\noff, which prevents any change to the memory."},"244.21":{"start":"244.209","dur":"3.731","text":"So we need to \u201copen\u201d the \u201cgate\u201d by\nturning the write enable wire to 1."},"247.95":{"start":"247.95","dur":"3.869","text":"Now we can put a 1 on the data line to save\nthe value 1 to our latch."},"251.82":{"start":"251.819","dur":"2.191","text":"Notice how the output is now 1."},"254.01":{"start":"254.01","dur":"0.81","text":"Success!"},"254.82":{"start":"254.82","dur":"3.58","text":"We can turn off the enable line and the output\nstays as 1."},"258.40":{"start":"258.4","dur":"3.559","text":"Once again, we can toggle the value on the\ndata line all we want, but the output will"},"261.96":{"start":"261.959","dur":"1","text":"stay the same."},"262.96":{"start":"262.959","dur":"2.031","text":"The value is saved in memory."},"264.99":{"start":"264.99","dur":"4.66","text":"Now let\u2019s turn the enable line on again\nuse our data line to set the latch to 0."},"269.65":{"start":"269.65","dur":"1","text":"Done."},"270.65":{"start":"270.65","dur":"2.26","text":"Enable line off, and the output is 0."},"272.91":{"start":"272.91","dur":"1.009","text":"And it works!"},"273.92":{"start":"273.919","dur":"3.271","text":"Now, of course, computer memory that only\nstores one bit of information isn\u2019t very"},"277.19":{"start":"277.19","dur":"2.59","text":"useful -- definitely not enough to run Frogger."},"279.78":{"start":"279.78","dur":"1.52","text":"Or anything, really."},"281.30":{"start":"281.3","dur":"2.18","text":"But we\u2019re not limited to using only one\nlatch."},"283.48":{"start":"283.48","dur":"4.79","text":"If we put 8 latches side-by-side, we can store\n8 bits of information like an 8-bit number."},"288.27":{"start":"288.27","dur":"5.13","text":"A group of latches operating like this is\ncalled a register, which holds a single number,"},"293.40":{"start":"293.4","dur":"2.66","text":"and the number of bits in a register is called\nits width."},"296.06":{"start":"296.06","dur":"5.759","text":"Early computers had 8-bit registers, then\n16, 32, and today, many computers have registers"},"301.82":{"start":"301.819","dur":"1.6","text":"that are 64-bits wide."},"303.42":{"start":"303.419","dur":"3.331","text":"To write to our register, we first have to\nenable all of the latches."},"306.75":{"start":"306.75","dur":"5.03","text":"We can do this with a single wire that connects to all of their enable inputs, which we set to 1."},"311.80":{"start":"311.8","dur":"5.52","text":"We then send our data in using the 8 data\nwires, and then set enable back to 0, and"},"317.32":{"start":"317.32","dur":"2.34","text":"the 8 bit value is now saved in memory."},"319.66":{"start":"319.66","dur":"3.76","text":"Putting latches side-by-side works ok for\na small-ish number of bits."},"323.43":{"start":"323.43","dur":"5.37","text":"A 64-bit register would need 64 wires running\nto the data pins, and 64 wires running to"},"328.80":{"start":"328.8","dur":"1.17","text":"the outputs."},"329.97":{"start":"329.97","dur":"6.53","text":"Luckily we only need 1 wire to enable all\nthe latches, but that\u2019s still 129 wires."},"336.50":{"start":"336.5","dur":"4.16","text":"For 256 bits, we end up with 513 wires!"},"340.66":{"start":"340.66","dur":"1.46","text":"The solution is a matrix!"},"342.14":{"start":"342.14","dur":"4","text":"In this matrix, we don\u2019t arrange our latches\nin a row, we put them in a grid."},"346.16":{"start":"346.16","dur":"6.36","text":"For 256 bits, we need a 16 by 16 grid of latches\nwith 16 rows and columns of wires."},"352.52":{"start":"352.52","dur":"4.47","text":"To activate any one latch, we must turn on\nthe corresponding row AND column wire."},"356.99":{"start":"356.99","dur":"1.94","text":"Let\u2019s zoom in and see how this works."},"358.93":{"start":"358.93","dur":"3.83","text":"We only want the latch at the intersection\nof the two active wires to be enabled,"},"362.78":{"start":"362.78","dur":"2.96","text":"but all of the other latches should stay disabled."},"365.78":{"start":"365.78","dur":"2.52","text":"For this, we can use our trusty AND gate!"},"368.31":{"start":"368.31","dur":"4.4","text":"The AND gate will output a 1 only if the row\nand the column wires are both 1."},"372.71":{"start":"372.71","dur":"3.01","text":"So we can use this signal to uniquely select\na single latch."},"375.72":{"start":"375.72","dur":"5.02","text":"This row\/column setup connects all our latches\nwith a single, shared, write enable wire."},"380.76":{"start":"380.76","dur":"3.96","text":"In order for a latch to become write enabled,\nthe row wire, the column wire, and the write"},"384.72":{"start":"384.72","dur":"1.64","text":"enable wire must all be 1."},"386.36":{"start":"386.36","dur":"3.5","text":"That should only ever be true for one single\nlatch at any given time."},"389.86":{"start":"389.86","dur":"2.97","text":"This means we can use a single, shared wire\nfor data."},"392.83":{"start":"392.83","dur":"4.33","text":"Because only one latch will ever be write\nenabled, only one will ever save the data"},"397.18":{"start":"397.18","dur":"3.36","text":"-- the rest of the latches will simply ignore\nvalues on the data wire because they are not"},"400.55":{"start":"400.55","dur":"1.28","text":"write enabled."},"401.83":{"start":"401.83","dur":"4.82","text":"We can use the same trick with a read enable\nwire to read the data later, to get the data"},"406.65":{"start":"406.65","dur":"2.019","text":"out of one specific latch."},"408.67":{"start":"408.669","dur":"6.332","text":"This means in total, for 256 bits of memory,\nwe only need 35 wires - 1 data wire, 1 write"},"415.00":{"start":"415.001","dur":"4.939","text":"enable wire, 1 read enable wire, and 16 rows\nand columns for the selection."},"419.94":{"start":"419.94","dur":"1.81","text":"That\u2019s significant wire savings!"},"421.75":{"start":"421.75","dur":"3.389","text":"But we need a way to uniquely specify each\nintersection."},"425.14":{"start":"425.139","dur":"3.28","text":"We can think of this like a city, where you\nmight want to meet someone at 12th avenue"},"428.42":{"start":"428.419","dur":"3.111","text":"and 8th street -- that&#39;s an address that defines\nan intersection."},"431.53":{"start":"431.53","dur":"4.43","text":"The latch we just saved our one bit into has\nan address of row 12 and column 8."},"435.96":{"start":"435.96","dur":"4.92","text":"Since there is a maximum of 16 rows, we store the row address in a 4 bit number."},"440.88":{"start":"440.88","dur":"2.86","text":"12 is 1100 in binary."},"443.74":{"start":"443.74","dur":"4.94","text":"We can do the same for the column address: 8 is 1000 in binary."},"448.68":{"start":"448.68","dur":"6.479","text":"So the address for the particular latch we\njust used can be written as 11001000."},"455.16":{"start":"455.159","dur":"3.871","text":"To convert from an address into something\nthat selects the right row or column, we need"},"459.03":{"start":"459.03","dur":"4.22","text":"a special component called a multiplexer -- which\nis the computer component with a pretty cool"},"463.25":{"start":"463.25","dur":"2.11","text":"name at least compared to the ALU."},"465.36":{"start":"465.36","dur":"4.7","text":"Multiplexers come in all different sizes,\nbut because we have 16 rows, we need a 1 to"},"470.07":{"start":"470.069","dur":"0.991","text":"16 multiplexer."},"471.07":{"start":"471.069","dur":"1.03","text":"It works like this."},"472.10":{"start":"472.099","dur":"4.581","text":"You feed it a 4 bit number, and it connects\nthe input line to a corresponding output line."},"476.68":{"start":"476.68","dur":"5.389","text":"So if we pass in 0000, it will select the\nvery first column for us."},"482.07":{"start":"482.069","dur":"4.18","text":"If we pass in 0001, the next column is selected,\nand so on."},"486.25":{"start":"486.249","dur":"4.44","text":"We need one multiplexer to handle our rows\nand another multiplexer to handle the columns."},"490.69":{"start":"490.689","dur":"5.951","text":"Ok, it\u2019s starting to get complicated again,\nso let\u2019s make our 256-bit memory its own component."},"496.80":{"start":"496.8","dur":"8.16","text":"Once again a new level of abstraction!"},"504.98":{"start":"504.98","dur":"4.72","text":"It takes an 8-bit address for input - the\n4 bits for the column and 4 for the row."},"509.70":{"start":"509.7","dur":"2.52","text":"We also need write and read enable wires."},"512.22":{"start":"512.22","dur":"4.86","text":"And finally, we need just one data wire, which\ncan be used to read or write data."},"517.08":{"start":"517.08","dur":"5","text":"Unfortunately, even 256-bits of memory isn\u2019t\nenough to run much of anything, so we need"},"522.09":{"start":"522.089","dur":"1.431","text":"to scale up even more!"},"523.53":{"start":"523.53","dur":"2.2","text":"We\u2019re going to put them in a row."},"525.73":{"start":"525.73","dur":"1.09","text":"Just like with the registers."},"526.82":{"start":"526.82","dur":"4.889","text":"We\u2019ll make a row of 8 of them, so we can\nstore an 8 bit number - also known as a byte."},"531.71":{"start":"531.709","dur":"5.501","text":"To do this, we feed the exact same address\ninto all 8 of our 256-bit memory components"},"537.21":{"start":"537.21","dur":"4.03","text":"at the same time, and each one saves one bit\nof the number."},"541.24":{"start":"541.24","dur":"6.64","text":"That means the component we just made can\nstore 256 bytes at 256 different addresses."},"547.90":{"start":"547.9","dur":"3.72","text":"Again, to keep things simple, we want to leave\nbehind this inner complexity."},"551.62":{"start":"551.62","dur":"4.1","text":"Instead of thinking of this as a series of\nindividual memory modules and circuits, we\u2019ll"},"555.72":{"start":"555.72","dur":"2.75","text":"think of it as a uniform bank of addressable\nmemory."},"558.47":{"start":"558.47","dur":"5.07","text":"We have 256 addresses, and at each address,\nwe can read or write an 8-bit value."},"563.54":{"start":"563.54","dur":"4.57","text":"We\u2019re going to use this memory component\nnext episode when we build our CPU."},"568.11":{"start":"568.11","dur":"4.159","text":"The way that modern computers scale to megabytes\nand gigabytes of memory is by doing the same"},"572.27":{"start":"572.269","dur":"4.161","text":"thing we\u2019ve been doing here -- keep packaging\nup little bundles of memory into larger, and"},"576.43":{"start":"576.43","dur":"1.36","text":"larger, and larger arrangements."},"577.79":{"start":"577.79","dur":"4.47","text":"As the number of memory locations grow, our\naddresses have to grow as well."},"582.26":{"start":"582.26","dur":"6.42","text":"8 bits hold enough numbers to provide addresses for 256 bytes of our memory, but that\u2019s all."},"588.68":{"start":"588.68","dur":"5.22","text":"To address a gigabyte \u2013 or a billion bytes\nof memory \u2013 we need 32-bit addresses."},"593.90":{"start":"593.9","dur":"4.16","text":"An important property of this memory is that\nwe can access any memory location, at any"},"598.07":{"start":"598.07","dur":"1.819","text":"time, and in a random order."},"599.89":{"start":"599.889","dur":"3.551","text":"For this reason, it\u2019s called Random-Access\nMemory or RAM."},"603.44":{"start":"603.44","dur":"4.1","text":"When you hear people talking about how much RAM a computer has - that&#39;s the computer\u2019s memory."},"607.64":{"start":"607.64","dur":"3.9","text":"RAM is like a human\u2019s short term or working\nmemory, where you keep track of things going"},"611.54":{"start":"611.54","dur":"3.21","text":"on right now - like whether or not you had\nlunch or paid your phone bill."},"614.75":{"start":"614.75","dur":"3.839","text":"Here\u2019s an actual stick of RAM - with 8 memory\nmodules soldered onto the board."},"618.59":{"start":"618.589","dur":"3.481","text":"If we carefully opened up one of these modules\nand zoomed in, The first thing you would see"},"622.07":{"start":"622.07","dur":"1.41","text":"are 32 squares of memory."},"623.48":{"start":"623.48","dur":"4.57","text":"Zoom into one of those squares, and we can\nsee each one is comprised of 4 smaller blocks."},"628.05":{"start":"628.05","dur":"3.4","text":"If we zoom in again, we get down to the matrix\nof individual bits."},"631.45":{"start":"631.45","dur":"3.31","text":"This is a matrix of 128 by 64 bits."},"634.76":{"start":"634.76","dur":"3.06","text":"That\u2019s 8192 bits in total."},"637.83":{"start":"637.829","dur":"6.091","text":"Each of our 32 squares has 4 matrices, so\nthat\u2019s 32 thousand, 7 hundred and 68 bits."},"643.93":{"start":"643.93","dur":"1.55","text":"And there are 32 squares in total."},"645.48":{"start":"645.48","dur":"4.38","text":"So all in all, that\u2019s roughly 1 million\nbits of memory in each chip."},"649.86":{"start":"649.86","dur":"4.979","text":"Our RAM stick has 8 of these chips, so in\ntotal, this RAM can store 8 millions bits,"},"654.84":{"start":"654.84","dur":"1.86","text":"otherwise known as 1 megabyte."},"656.70":{"start":"656.7","dur":"3.94","text":"That\u2019s not a lot of memory these days -- this\nis a RAM module from the 1980\u2019s."},"660.65":{"start":"660.65","dur":"5.02","text":"Today you can buy RAM that has a gigabyte\nor more of memory - that\u2019s billions of bytes"},"665.67":{"start":"665.67","dur":"0.63","text":"of memory."},"666.40":{"start":"666.4","dur":"4.6","text":"So, today, we built a piece of SRAM - Static\nRandom-Access Memory \u2013 which uses latches."},"671.02":{"start":"671.02","dur":"4.02","text":"There are other types of RAM, such as DRAM, Flash memory, and NVRAM."},"675.04":{"start":"675.04","dur":"4.299","text":"These are very similar in function to SRAM,\nbut use different circuits to store the individual"},"679.34":{"start":"679.34","dur":"4.76","text":"bits -- for example, using different logic\ngates, capacitors, charge traps, or memristors."},"684.10":{"start":"684.1","dur":"4.88","text":"But fundamentally, all of these technologies\nstore bits of information in massively nested"},"688.99":{"start":"688.99","dur":"2.01","text":"matrices of memory cells."},"691.02":{"start":"691.019","dur":"4.641","text":"Like many things in computing, the fundamental\noperation is relatively simple.. it\u2019s the"},"695.66":{"start":"695.66","dur":"4.511","text":"layers and layers of abstraction that\u2019s\nmind blowing -- like a russian doll that"},"700.18":{"start":"700.18","dur":"2.72","text":"keeps getting smaller and smaller and smaller."},"702.90":{"start":"702.9","dur":"1.82","text":"I\u2019ll see you next week."},"704.72":{"start":"704.72","dur":"21.76","text":"Credits"}}